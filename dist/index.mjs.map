{"version":3,"sources":["../src/utils/storage.ts","../src/index.ts","../src/hooks/use-query.tsx","../src/utils/service.ts","../src/config.ts","../src/store/reducers/cache-reducer.tsx","../src/store/reducers/app-reducer.tsx","../src/store/contexts/app-context.tsx","../src/store/contexts/socket-context.tsx","../src/utils/toast.ts","../src/hooks/use-selector.tsx","../src/hooks/use-dispatch.tsx","../src/store/reducers/thread-reducer.tsx","../src/hooks/use-cache.tsx","../src/paths.ts","../src/hooks/utils/route-parser.ts","../src/hooks/constants.ts","../src/hooks/utils/error-handler.ts","../src/hooks/utils/request-queue.ts","../src/hooks/utils/cache-helpers.ts","../src/hooks/use-query-async.tsx","../src/hooks/use-mutation.tsx","../src/hooks/use-mutation-async.tsx","../src/utils/http-helpers.ts","../src/hooks/utils/debug-logger.ts","../src/hooks/utils/retry-manager.ts","../src/hooks/utils/offline-queue.ts","../src/hooks/utils/refetch-manager.ts","../src/store/index.ts","../src/utils/money.ts","../src/utils/crypto.ts"],"sourcesContent":["import { MMKV } from 'react-native-mmkv'\n\nconst storage = new MMKV()\n\nclass Storage {\n\n    setItem=(key:string, value:any)=> {\n        try {\n            return storage.set(key, JSON.stringify(value))\n        } catch (e) {\n        }\n    };\n\n    getItem=(key:string)=> {\n        try {\n            const value = storage.getString(key);\n            if (value) {\n                return JSON.parse(value)\n            }\n            return undefined\n        } catch(e) {\n        }\n    };\n\n    removeItem=(key:string)=> {\n        try {\n            storage.delete(key)\n        } catch(e) {\n            // remove error\n        }\n    };\n\n    clear=async ()=> (\n        storage.clearAll()\n    )\n\n}\n\nexport default new Storage()\n","import dayjs from 'dayjs';\nimport relativeTime from 'dayjs/plugin/relativeTime';\nimport utc from 'dayjs/plugin/utc';\nimport timezone from 'dayjs/plugin/timezone';\n\ndayjs.extend(relativeTime);\ndayjs.extend(utc);\ndayjs.extend(timezone);\n\n// Hooks exports\nexport { default as useQuery } from './hooks/use-query';\nexport { default as useQueryAsync } from './hooks/use-query-async';\nexport { default as useMutation } from './hooks/use-mutation';\nexport { default as useMutationAsync } from './hooks/use-mutation-async';\nexport { default as useDispatch } from './hooks/use-dispatch';\nexport { default as useSelector } from './hooks/use-selector';\nexport { default as useCache } from './hooks/use-cache';\nexport { useApp } from './store/contexts/app-context';\nexport { dayjs };\n\n// Hook types\nexport type {\n  QueryOptions,\n  QueryResult,\n  MutationOptions,\n  MutationResponse,\n  MutationResult,\n  CacheOperations,\n  TimingInfo,\n} from './hooks/types';\nexport type { NetworkPolicy, ConcatStrategy } from './hooks/constants';\nexport type {\n  ParsedRoute,\n  ErrorResponse,\n  SuccessResponse,\n  ApiResponse,\n} from './hooks/utils';\n\n// Cache types\nexport type { CacheEntry, CacheState, CacheMetadata } from './store/reducers/cache-reducer';\nexport { setMaxCacheSize, getCacheMetadata } from './store/reducers/cache-reducer';\n\n// HTTP service types and utilities\nexport type { HttpOptions, ContentType, HttpResponse } from './utils/service';\nexport { isAbortError as isHttpAbortError } from './utils/service';\n\n// HTTP helper utilities\nexport {\n  createAbortController,\n  isAbortError,\n  isCancelError,\n  shouldRetry,\n  formatFormData,\n  formatUrlEncoded,\n  safeAbort,\n  createTimeoutController,\n  combineAbortSignals,\n} from './utils/http-helpers';\n\n// Error handler utilities\nexport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  createErrorResponse,\n  createSuccessResponse,\n} from './hooks/utils/error-handler';\n\n// NEW: Request deduplication\nexport {\n  getOrCreateRequest,\n  cancelRequest,\n  isRequestInFlight,\n  getInFlightCount,\n  clearAllRequests,\n} from './hooks/utils/request-queue';\n\n// NEW: Cache helpers\nexport {\n  isCacheExpired,\n  isCacheStale,\n  isCacheFresh,\n  getCacheData,\n  createCacheEntry,\n  getCacheAge,\n  canUseCache,\n} from './hooks/utils/cache-helpers';\n\n// NEW: Debug logger\nexport {\n  QueryDebugger,\n  createDebugger,\n  enableGlobalDebug,\n  disableGlobalDebug,\n  isGlobalDebugEnabled,\n} from './hooks/utils/debug-logger';\nexport type { QueryDebugInfo } from './hooks/utils/debug-logger';\n\n// NEW: Retry manager\nexport {\n  retryWithBackoff,\n  retryWithJitter,\n} from './hooks/utils/retry-manager';\nexport type { RetryOptions } from './hooks/utils/retry-manager';\n\n// NEW: Offline queue\nexport {\n  OfflineQueue,\n  getOfflineQueue,\n} from './hooks/utils/offline-queue';\nexport type { QueuedMutation } from './hooks/utils/offline-queue';\n\n// NEW: Refetch hooks\nexport {\n  useRefetchOnFocus,\n  useRefetchOnReconnect,\n  useRefetchInterval,\n} from './hooks/utils/refetch-manager';\n\n// Store exports\nexport { default as AppProvider } from './store/contexts/app-context';\nexport { store } from './store';\nexport type { AppDispatch, RootState } from './store';\n\nexport { config as alphaConfig} from './config';\nexport { default as PATHS } from './paths';\nexport * from './types';\n\nexport { default as formatMoney } from './utils/money';\nexport * from './utils/crypto';\nexport { default as storage } from './utils/storage';\n\n// NEW: Constants\nexport {\n  DEFAULT_CACHE_TTL,\n  DEFAULT_STALE_TIME,\n  MAX_CACHE_SIZE,\n  NETWORK_TIMEOUT,\n  ERROR_MESSAGES,\n  STATUS_CODES,\n} from './hooks/constants';\n","import { useEffect, useMemo, useRef, useCallback } from \"react\";\nimport http, { Method } from \"../utils/service\";\nimport { useApp } from \"../store/contexts/app-context\";\nimport useDispatch from \"./use-dispatch\";\nimport useSelector from \"./use-selector\";\nimport { actions } from \"../store/reducers/cache-reducer\";\nimport * as network from \"../store/reducers/thread-reducer\";\nimport useCache from \"./use-cache\";\nimport { useSocket } from \"../store/contexts/socket-context\";\nimport { Route } from \"../types\";\nimport { QueryOptions, QueryResult } from \"./types\";\nimport { NetworkPolicy, NETWORK_TIMEOUT } from \"./constants\";\nimport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  isAbortError,\n} from \"./utils/error-handler\";\nimport { getOrCreateRequest, cancelRequest } from \"./utils/request-queue\";\nimport {\n  isCacheExpired,\n  isCacheStale,\n  getCacheData,\n} from \"./utils/cache-helpers\";\n\n/**\n * Custom hook for data fetching with caching support\n * @param route - The API route key\n * @param args - Query options including variables, network policy, callbacks\n * @returns QueryResult with data, loading state, and cache manipulation functions\n */\nconst useQuery = (route: Route, args?: QueryOptions): QueryResult => {\n  const { variables = {}, networkPolicy, init, onCompleted, onError } = args || {};\n  const app = useApp();\n  const { auth } = app;\n  const cache = useCache();\n  const { key, path, method } = cache.getContext(route, variables);\n  const policy: NetworkPolicy = networkPolicy || \"cache-first\";\n\n  const data = useSelector((state) => state.cache[key]);\n  const thread = useSelector((state) => state.tread[key]);\n\n  const dispatch = useDispatch();\n  const { connected } = useSocket();\n  \n  // Use ref to store timeout ID for cleanup\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n  \n  // Use ref to store abort controller for request cancellation\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Handle data completion and retry on connection\n  useEffect(() => {\n    if (data && onCompleted) {\n      onCompleted(data);\n    }\n    if (connected && thread?.error && (!data || (Array.isArray(data) && data.length < 1))) {\n      refetch({});\n    }\n  }, [data, connected, thread?.error]);\n\n  // Initial fetch on mount\n  useEffect(() => {\n    fetchData(variables);\n    \n    // Cleanup on unmount\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  // Handle initial data\n  useEffect(() => {\n    if (init && init.timestamp > (data?.timestamp || 0)) {\n      dispatch(actions.init({ key, value: init }));\n    }\n  }, [init?.timestamp, key, dispatch, data?.timestamp]);\n\n  /**\n   * Sets the loading/error state for this query\n   */\n  const setThread = useCallback(\n    (loading: boolean, error?: string) => {\n      dispatch(\n        network.actions.set({\n          key,\n          value: {\n            loading,\n            error,\n          },\n        })\n      );\n    },\n    [dispatch, key]\n  );\n\n  /**\n   * Main fetch logic based on network policy\n   */\n  const fetchData = useCallback(\n    (fetchVariables: Record<string, any>) => {\n      switch (policy) {\n        case \"cache-only\":\n          return;\n        case \"network-only\":\n          fetchHandler(fetchVariables).catch(() => {});\n          return;\n        case \"cache-first\":\n          if (!data) {\n            fetchHandler(fetchVariables).catch(() => {});\n          }\n          return;\n        case \"network-and-cache\":\n          fetchHandler(fetchVariables).catch(() => {});\n          timeoutRef.current = setTimeout(() => {\n            const currentThread = thread;\n            if (currentThread?.loading) {\n              refetch({});\n            }\n          }, NETWORK_TIMEOUT);\n          return;\n        case \"stale-while-revalidate\":\n          // Show stale data immediately if available and not expired\n          if (data && !isCacheExpired(data)) {\n            // If data is stale, refetch in background\n            if (isCacheStale(data)) {\n              fetchHandler(fetchVariables).catch(() => {});\n            }\n          } else {\n            // No cache or expired, fetch normally\n            fetchHandler(fetchVariables).catch(() => {});\n          }\n          return;\n      }\n    },\n    [policy, data, thread]\n  );\n\n  /**\n   * Handles the actual HTTP request\n   */\n  const fetchHandler = useCallback(\n    async (fetchVariables: Record<string, any>, isRefetch: boolean = false) => {\n      try {\n        // Only fetch if not currently loading or if it's a refetch or there's an error\n        if (!thread?.loading || thread?.error || isRefetch) {\n          // Abort any existing request\n          if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n          }\n          \n          // Create new abort controller for this request\n          abortControllerRef.current = new AbortController();\n          \n          setThread(true);\n          \n          // Use request deduplication to prevent duplicate requests\n          const res: any = await getOrCreateRequest(key, () =>\n            http(\n              path,\n              (method as Method) || \"GET\",\n              fetchVariables,\n              {\n                returnStatus: true,\n                auth: auth.accessToken,\n                signal: abortControllerRef.current.signal,\n              }\n            )\n          );\n          \n          const error = !isSuccessStatus(res.status)\n            ? extractErrorMessage(res)\n            : undefined;\n          \n          setThread(false, error);\n\n          if (isSuccessStatus(res.status) && res.data.data) {\n            if (onCompleted) {\n              onCompleted(res.data.data);\n            }\n            cache.setCache(key, res.data.data);\n          } else if (isAuthError(res.status)) {\n            app.setTimeout().catch(() => {});\n          } else if (error && onError) {\n            onError(error, res.status);\n          }\n        }\n      } catch (e: any) {\n        // Ignore abort errors - they're intentional cancellations\n        if (isAbortError(e)) {\n          return;\n        }\n        \n        const error = e.message || \"Oops! an error occurred\";\n        setThread(false, error);\n        if (onError) {\n          onError(error, 500);\n        }\n      }\n    },\n    [thread, setThread, path, method, auth.accessToken, onCompleted, onError, cache, key, app]\n  );\n\n  /**\n   * Refetches data with optional new variables\n   */\n  const refetch = useCallback(\n    (refetchVariables?: Record<string, any>) => {\n      fetchHandler({ ...variables, ...(refetchVariables || {}) }, true).catch(() => {});\n    },\n    [fetchHandler, variables]\n  );\n\n  /**\n   * Fetches more data and concatenates with existing data\n   */\n  const fetchMore = useCallback(\n    async (\n      fetchMoreVariables?: Record<string, any>,\n      concat?: \"start\" | \"end\" | \"pagination\",\n      paginationKey?: string\n    ) => {\n      try {\n        // Create abort controller for fetchMore\n        const fetchMoreController = new AbortController();\n        \n        const res: any = await http(\n          path,\n          (method as Method) || \"GET\",\n          { ...variables, ...(fetchMoreVariables || {}) },\n          {\n            returnStatus: true,\n            auth: auth?.accessToken,\n            signal: fetchMoreController.signal,\n          }\n        );\n        \n        const error = !isSuccessStatus(res.status)\n          ? extractErrorMessage(res)\n          : undefined;\n\n        if (isSuccessStatus(res.status)) {\n          if (concat === \"start\") {\n            dispatch(actions.prepend({ key, value: res.data.data }));\n          } else if (concat === \"end\") {\n            dispatch(actions.append({ key, value: res.data.data }));\n          } else if (concat === \"pagination\") {\n            dispatch(\n              actions.paginate({\n                key,\n                data: res.data.data,\n                paginationKey: paginationKey || \"data\",\n              })\n            );\n          }\n          return { data: res.data.data };\n        } else if (isAuthError(res.status)) {\n          app.setTimeout().catch(() => {});\n          return { error };\n        }\n        return { error };\n      } catch (e: any) {\n        // Handle abort errors\n        if (isAbortError(e)) {\n          return { error: \"Request cancelled\" };\n        }\n        \n        const error = e.message || \"Oops! an error occurred\";\n        return { error };\n      }\n    },\n    [path, method, variables, auth?.accessToken, dispatch, key, app]\n  );\n\n  /**\n   * Aborts the current request\n   */\n  const abort = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n    // Also remove from deduplication queue\n    cancelRequest(key);\n  }, [key]);\n\n  /**\n   * Optimistic update with automatic rollback\n   */\n  const optimisticUpdate = useCallback(\n    (updater: (current: any) => any, rollback?: () => void) => {\n      const currentData = data;\n      const newData = updater(currentData);\n\n      // Update immediately\n      cache.update(key, newData);\n\n      // Return rollback function\n      return () => {\n        if (rollback) {\n          rollback();\n        } else {\n          cache.update(key, currentData);\n        }\n      };\n    },\n    [data, key, cache]\n  );\n\n  /**\n   * Cache manipulation functions bound to current key\n   */\n  const extendCache = useMemo(\n    () => ({\n      update: (newData: any) => {\n        cache.update(key, newData);\n      },\n      updateValue: (arg: string, value: any) => {\n        cache.updateValue(key, arg, value);\n      },\n      updateValues: (values: Record<string, any>) => {\n        cache.updateValues(key, values);\n      },\n      updateItem: (id: string, value: any) => {\n        cache.updateItem(key, id, value);\n      },\n      deleteItem: (id: string) => {\n        cache.deleteItem(key, id);\n      },\n      prepend: (newData: any) => {\n        cache.prepend(key, newData);\n      },\n      append: (newData: any) => {\n        cache.append(key, newData);\n      },\n    }),\n    [key, cache]\n  );\n\n  return {\n    data: data || init,\n    loading: thread?.loading || false,\n    error: thread?.error,\n    refetch,\n    key,\n    fetchMore,\n    abort,\n    optimisticUpdate,\n    ...extendCache,\n  };\n};\n\nexport default useQuery;\n","import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport config from 'config';\n\nexport type Method = 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH';\nexport type ContentType = 'json' | 'urlencoded' | 'multipart';\n\nexport interface HttpOptions {\n  auth?: string;\n  contentType?: ContentType;\n  signal?: AbortSignal;\n  timeout?: number;\n  returnStatus?: boolean;\n  returnText?: boolean;\n}\n\nexport interface HttpResponse<T = any> {\n  data: {\n    data?: T;\n    error?: string;\n    ResponseDescription?: string;\n  };\n  status: number;\n}\n\n/**\n * Creates and configures an Axios instance with base configuration\n */\nconst createAxiosInstance = (): AxiosInstance => {\n  const instance = axios.create({\n    baseURL: config.baseUrl,\n    timeout: 30000, // 30 seconds default\n    headers: {\n      Accept: 'application/json',\n    },\n  });\n\n  // Response interceptor for standardized error handling\n  instance.interceptors.response.use(\n    (response) => response,\n    (error) => {\n      // Don't transform abort errors\n      if (axios.isCancel(error) || error.name === 'AbortError') {\n        return Promise.reject(error);\n      }\n\n      // Network error\n      if (!error.response) {\n        return Promise.resolve({\n          data: {\n            error: error.message || 'Network error occurred',\n          },\n          status: 500,\n        });\n      }\n\n      // HTTP error response\n      return Promise.resolve(error.response);\n    }\n  );\n\n  return instance;\n};\n\n// Singleton axios instance\nconst axiosInstance = createAxiosInstance();\n\n/**\n * Converts object to URL-encoded string\n */\nconst formatUrlEncoded = (data: Record<string, any>): string => {\n  const formBody: string[] = [];\n  for (const property in data) {\n    const encodedKey = encodeURIComponent(property);\n    const encodedValue = encodeURIComponent(data[property]);\n    formBody.push(`${encodedKey}=${encodedValue}`);\n  }\n  return formBody.join('&');\n};\n\n/**\n * Converts object to FormData for multipart requests\n */\nconst formatFormData = (data: Record<string, any>): FormData => {\n  const formData = new FormData();\n  for (const key in data) {\n    formData.append(key, data[key]);\n  }\n  return formData;\n};\n\n/**\n * Get appropriate Content-Type header based on type\n */\nconst getContentTypeHeader = (contentType: ContentType): string => {\n  switch (contentType) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded';\n    case 'multipart':\n      return 'multipart/form-data';\n    case 'json':\n    default:\n      return 'application/json';\n  }\n};\n\n/**\n * Format request data based on content type\n */\nconst formatRequestData = (\n  data: any,\n  contentType: ContentType,\n  method: Method\n): any => {\n  // GET requests don't have body\n  if (method === 'GET') {\n    return undefined;\n  }\n\n  if (!data) {\n    return undefined;\n  }\n\n  switch (contentType) {\n    case 'urlencoded':\n      return formatUrlEncoded(data);\n    case 'multipart':\n      return formatFormData(data);\n    case 'json':\n    default:\n      return data;\n  }\n};\n\n/**\n * Modern HTTP client with axios\n * Supports multiple Content-Types, request cancellation, and better error handling\n * \n * @param path - API endpoint path\n * @param method - HTTP method (GET, POST, PUT, DELETE, PATCH)\n * @param data - Request data (body for POST/PUT/PATCH, query params for GET)\n * @param options - Additional options (auth, contentType, signal, timeout, etc.)\n * @returns Promise with standardized response format\n * \n * @example\n * // JSON request (default)\n * const response = await http('/users', 'POST', { name: 'John' });\n * \n * @example\n * // URL-encoded request\n * const response = await http('/login', 'POST', { email, password }, { contentType: 'urlencoded' });\n * \n * @example\n * // With abort signal\n * const controller = new AbortController();\n * const response = await http('/data', 'GET', {}, { signal: controller.signal });\n * // Later: controller.abort();\n */\nasync function http<T = any>(\n  path: string,\n  method?: Method,\n  data?: any,\n  options?: HttpOptions\n): Promise<HttpResponse<T>>;\n\n// Legacy signature for backward compatibility\nasync function http<T = any>(\n  path: string,\n  method: Method,\n  data: any,\n  returnStatus: boolean,\n  auth?: string,\n  returnText?: boolean\n): Promise<HttpResponse<T>>;\n\n// Implementation\nasync function http<T = any>(\n  path: string,\n  method: Method = 'GET',\n  data?: any,\n  optionsOrStatus?: HttpOptions | boolean,\n  legacyAuth?: string,\n  legacyReturnText?: boolean\n): Promise<HttpResponse<T>> {\n  // Handle legacy signature\n  let options: HttpOptions;\n  if (typeof optionsOrStatus === 'boolean') {\n    options = {\n      returnStatus: optionsOrStatus,\n      auth: legacyAuth,\n      returnText: legacyReturnText,\n      contentType: 'urlencoded', // Legacy default\n    };\n  } else {\n    options = optionsOrStatus || {};\n  }\n\n  const {\n    auth,\n    contentType = 'json',\n    signal,\n    timeout,\n    returnStatus = true,\n    returnText = false,\n  } = options;\n\n  try {\n    // Prepare headers\n    const headers: Record<string, string> = {\n      'Content-Type': getContentTypeHeader(contentType),\n    };\n\n    if (auth) {\n      headers['Auth_IDToken'] = auth;\n    }\n\n    // Prepare request config\n    const config: AxiosRequestConfig = {\n      method,\n      url: path,\n      headers,\n      signal,\n      timeout: timeout || 30000,\n    };\n\n    // Handle data based on method and content type\n    if (method === 'GET' && data) {\n      // For GET, data becomes query params\n      config.params = data;\n    } else {\n      // For other methods, format body based on content type\n      config.data = formatRequestData(data, contentType, method);\n    }\n\n    // Make the request\n    const response: AxiosResponse = await axiosInstance.request(config);\n\n    // Format response based on options\n    if (returnStatus) {\n      return {\n        data: {\n          data: returnText\n            ? response.data\n            : typeof response.data === 'string'\n            ? response.data\n            : response.data,\n        },\n        status: response.status,\n      };\n    }\n\n    return response.data;\n  } catch (error: any) {\n    // Re-throw abort/cancel errors so they can be handled by the caller\n    if (axios.isCancel(error) || error.name === 'AbortError') {\n      throw error;\n    }\n\n    // Return error response in standard format\n    return {\n      data: {\n        error: error.message || 'An error occurred',\n      },\n      status: error.response?.status || 500,\n    };\n  }\n}\n\nexport default http;\n\n/**\n * Check if an error is an abort/cancel error\n */\nexport const isAbortError = (error: any): boolean => {\n  return (\n    axios.isCancel(error) ||\n    error.name === 'AbortError' ||\n    error.name === 'CanceledError'\n  );\n};\n","export const naira = 'â‚¦';\n\nexport const config = {\n  naira,\n  baseUrl: '',\n};\n\nexport default config;\n","import {createSlice, PayloadAction} from \"@reduxjs/toolkit\";\n\n/**\n * Cache entry structure with TTL support\n */\nexport interface CacheEntry {\n  data: any;\n  timestamp: number;\n  expiresAt?: number;\n  staleAt?: number;\n}\n\nexport interface CacheState {\n  [key: string]: CacheEntry | any; // any for backward compatibility\n}\n\nexport interface CacheMetadata {\n  accessOrder: string[];\n  maxSize: number;\n}\n\n// Separate metadata state (not serialized in Redux)\nconst metadata: CacheMetadata = {\n  accessOrder: [],\n  maxSize: 100, // Default LRU limit\n};\n\nconst initialState: CacheState = {};\n\nconst cacheSlice = createSlice({\n    name: 'cache',\n    initialState,\n    reducers: {\n        init(state, action: PayloadAction<any>) {\n            state[action.payload.key] = {\n                ...(state[action.payload.key]||{}),\n                ...action.payload.value,\n            }\n        },\n        set(state, action: PayloadAction<{ key:string, value:any, ttl?:number, staleTime?:number }>) {\n            const timestamp = Date.now();\n            const { key, value, ttl, staleTime } = action.payload;\n            \n            // Update LRU access order\n            updateAccessOrder(state, key);\n            \n            // Create cache entry with TTL support\n            const entry: CacheEntry = {\n              data: value,\n              timestamp,\n              expiresAt: ttl ? timestamp + ttl : undefined,\n              staleAt: staleTime !== undefined ? timestamp + staleTime : undefined,\n            };\n            \n            state[key] = entry;\n        },\n        prepend(state, action: PayloadAction<{ key:string, value:any[] }>) {\n            const timestamp = new Date().getTime()\n            state[action.payload.key] = action.payload.value.map((data:any)=>({...data, timestamp})).concat(state[action.payload.key]||[])\n        },\n        append(state, action: PayloadAction<{ key:string, value:any[] }>) {\n            const timestamp = new Date().getTime()\n            state[action.payload.key] = (state[action.payload.key]||[]).concat(action.payload.value.map((data:any)=>({...data, timestamp})))\n        },\n        paginate(state, action: PayloadAction<{ key:string, data:any, paginationKey:string }>) {\n            const timestamp = new Date().getTime()\n            const {key, data, paginationKey} = action.payload\n            state[key] = {\n                ...data,\n                [paginationKey]: [...state[key][paginationKey], ...data[paginationKey]],\n                timestamp\n            }\n        },\n        remove(state, action: PayloadAction<string>) {\n            delete state[action.payload];\n            /*const spr:any = {...state}\n            delete spr[action.payload];\n            state = spr*/\n        },\n        clear:()=> initialState,\n        \n        // New action to delete a specific cache entry\n        delete(state, action: PayloadAction<{ key:string }>) {\n            const { key } = action.payload;\n            delete state[key];\n            // Remove from access order\n            const index = metadata.accessOrder.indexOf(key);\n            if (index > -1) {\n                metadata.accessOrder.splice(index, 1);\n            }\n        },\n\n    },\n});\n\n/**\n * Updates LRU access order and evicts if necessary\n */\nfunction updateAccessOrder(state: CacheState, key: string) {\n  // Remove key if it exists\n  const index = metadata.accessOrder.indexOf(key);\n  if (index > -1) {\n    metadata.accessOrder.splice(index, 1);\n  }\n  \n  // Add to end (most recent)\n  metadata.accessOrder.push(key);\n  \n  // Evict oldest if over limit\n  if (metadata.accessOrder.length > metadata.maxSize) {\n    const evictKey = metadata.accessOrder.shift();\n    if (evictKey) {\n      delete state[evictKey];\n    }\n  }\n}\n\n/**\n * Set the maximum cache size for LRU eviction\n */\nexport function setMaxCacheSize(size: number) {\n  metadata.maxSize = size;\n}\n\n/**\n * Get current cache metadata (for debugging)\n */\nexport function getCacheMetadata(): Readonly<CacheMetadata> {\n  return { ...metadata };\n}\n\nexport const actions = cacheSlice.actions;\nexport default cacheSlice.reducer;\n","import {Visibility} from 'types';\nimport {PayloadAction, createSlice} from '@reduxjs/toolkit';\n\nimport uuid from 'react-native-uuid';\n\nexport interface AppState {\n  auth: {\n    accessToken: string;\n    customerId: string;\n    user: any;\n  };\n  registered: boolean;\n  deviceId: any;\n  email: string;\n  image: string;\n  defaultPassword: boolean;\n  biometric: boolean;\n  visibility: {\n    wallet: boolean;\n    savings: boolean;\n    total: boolean;\n    investment: boolean;\n  };\n}\n\nconst initialState: AppState = {\n  auth: {\n    accessToken: '',\n    customerId: '',\n    user: {},\n  },\n  registered: false,\n  deviceId: uuid.v4(),\n  email: '',\n  image: '',\n  defaultPassword: false,\n  biometric: false,\n  visibility: {\n    wallet: true,\n    savings: true,\n    total: true,\n    investment: true,\n  },\n};\n\nconst appSlice = createSlice({\n  name: 'app',\n  initialState,\n  reducers: {\n    setDeviceId(state, action: PayloadAction<string>) {\n      state.deviceId = action.payload;\n    },\n    setAuth(\n      state,\n      action: PayloadAction<{auth_idtoken: string; session_token_id: string}>,\n    ) {\n      state.auth = {\n        accessToken: action.payload.auth_idtoken,\n        customerId: action.payload.session_token_id,\n        user: {},\n      };\n    },\n    setUser(state, action: PayloadAction<{}>) {\n      state.auth.user = action.payload;\n    },\n    setEmail(state, action: PayloadAction<string>) {\n      state.email = action.payload;\n    },\n    setImage(state, action: PayloadAction<string>) {\n      state.image = action.payload;\n    },\n    setRegistered(state, action: PayloadAction<boolean>) {\n      state.registered = action.payload;\n    },\n    setDefaultPassword(state, action: PayloadAction<boolean>) {\n      state.defaultPassword = action.payload;\n    },\n    setBiometric(state, action: PayloadAction<boolean>) {\n      state.biometric = action.payload;\n    },\n    toggleVisibility(state, action: PayloadAction<Visibility>) {\n      state.visibility[action.payload] = !state.visibility[action.payload];\n    },\n    setLogout(state) {\n      state.auth = initialState.auth;\n    },\n  },\n});\n\nexport const actions = appSlice.actions;\nexport default appSlice.reducer;\n","import * as cache from '../reducers/cache-reducer';\n\nimport {AppState, actions} from '../reducers/app-reducer';\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react';\n\nimport NetInfo from '@react-native-community/netinfo';\nimport SocketContext from './socket-context';\nimport Toast from '../../utils/toast';\nimport {Visibility} from 'types';\nimport {useNavigation} from '@react-navigation/native';\nimport useSelector from \"hooks/use-selector\";\nimport useDispatch from \"hooks/use-dispatch\";\n\ninterface Props extends AppState {\n  setEmail: (payload: string) => void;\n  setImage: (payload: string) => void;\n  setRegistered: (payload: boolean) => void;\n  setUser: (payload: any) => void;\n  setAuth: (payload: any) => void;\n  setLogout: () => Promise<void>;\n  setTimeout: () => Promise<void>;\n  setDefaultPassword: (value: boolean) => void;\n  setBiometric: (value: boolean) => void;\n  toggleVisibility: (value: Visibility) => void;\n  connected: boolean;\n}\n\nconst defaultValue: any = {};\n\nconst AppContext = createContext<Props>(defaultValue);\nexport const useApp = () => useContext(AppContext);\n\nconst AppProvider: React.FC<any> = ({children}) => {\n  const {reset} = useNavigation<any>();\n  const state = useSelector(appstate => appstate.app);\n  const dispatch = useDispatch();\n  const [connected, setConnected] = useState(false);\n\n  useEffect(() => {\n    const unsubscribe = NetInfo.addEventListener(internetState => {\n      if (internetState.isInternetReachable) {\n        setConnected(true);\n      } else {\n        setConnected(false);\n      }\n    });\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  const func = useMemo(\n    () => ({\n      setAuth: (payload: any) => {\n        dispatch(actions.setAuth(payload));\n      },\n      setUser: (payload: any) => {\n        dispatch(actions.setUser(payload));\n      },\n      setEmail: (payload: string) => {\n        dispatch(actions.setEmail(payload));\n      },\n      setImage: (payload: string) => {\n        dispatch(actions.setImage(payload));\n      },\n      setRegistered: (payload: boolean) => {\n        dispatch(actions.setRegistered(payload));\n      },\n      setDefaultPassword: (payload: boolean) => {\n        dispatch(actions.setDefaultPassword(payload));\n      },\n      setBiometric: (payload: boolean) => {\n        dispatch(actions.setBiometric(payload));\n      },\n      toggleVisibility: (payload: Visibility) => {\n        dispatch(actions.toggleVisibility(payload));\n      },\n      setTimeout: async () => {\n        Toast('Session expired! kindly login', 'SHORT');\n        func.setLogout().catch(() => {});\n      },\n      setLogout: async () => {\n        dispatch(actions.setLogout());\n        dispatch(cache.actions.clear());\n        reset({\n          index: 0,\n          routes: [\n            // { name: 'welcome' },\n            {name: 'login'},\n          ],\n        });\n      },\n    }),\n    [dispatch, reset],\n  );\n\n  const value = useMemo(\n    () => ({...state, connected, ...func}),\n    [state, connected, func],\n  );\n\n  return (\n    <AppContext.Provider value={value}>\n      <SocketContext>{children}</SocketContext>\n    </AppContext.Provider>\n  );\n};\n\nexport default AppProvider;\n","import React, {\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\n\nimport NetInfo from '@react-native-community/netinfo';\n\ntype Props = {\n  connected: boolean;\n};\n\nconst defaultValue: any = {};\n\nconst SocketContext = createContext<Props>(defaultValue);\nexport const useSocket = () => useContext(SocketContext);\n\nconst SocketProvider: React.FC<any> = ({children}) => {\n  const [connected, setConnected] = useState(false);\n\n  useEffect(() => {\n    const unsubscribe = NetInfo.addEventListener(state => {\n      if (state.isInternetReachable) {\n        setConnected(true);\n      } else {\n        setConnected(false);\n      }\n    });\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  return (\n    <SocketContext.Provider\n      value={{\n        connected,\n      }}>\n      {children}\n    </SocketContext.Provider>\n  );\n};\n\nexport default SocketProvider;\n","import SimpleToast from \"react-native-simple-toast\";\n\nconst Toast=(message:string, duration?:\"SHORT\"|\"LONG\")=>{\n    setTimeout(()=>{\n        SimpleToast.show(message,SimpleToast[duration||\"LONG\"])\n    },100)\n};\n\nexport default Toast;\n","import { TypedUseSelectorHook, useSelector as Selector } from 'react-redux';\nimport { RootState, AppDispatch } from '../store';\n\nconst useSelector: TypedUseSelectorHook<RootState> = Selector;\n\nexport default useSelector;\n","import { AppDispatch } from '../store';\nimport { useDispatch } from 'react-redux';\n\nexport default () => useDispatch<AppDispatch>();\n","import {createSlice, PayloadAction} from \"@reduxjs/toolkit\";\n\nconst initialState:any = {};\n\nconst threadSlice = createSlice({\n    name: 'thread',\n    initialState,\n    reducers: {\n        set(state, action: PayloadAction<{ key:string, value:{ loading:boolean, error?:string } }>) {\n            state[action.payload.key] = action.payload.value\n        },\n        remove(state, action: PayloadAction<string>) {\n            delete state[action.payload];\n            /*const spr:any = {...state}\n            delete spr[action.payload];\n            state = spr*/\n        },\n        clear:()=> initialState\n\n    },\n});\n\nexport const actions = threadSlice.actions;\nexport default threadSlice.reducer;\n","import { useCallback } from \"react\";\nimport { useApp } from \"../store/contexts/app-context\";\nimport useDispatch from \"./use-dispatch\";\nimport useSelector from \"./use-selector\";\nimport { actions } from \"../store/reducers/cache-reducer\";\nimport { Route } from \"../types\";\nimport { parseRoute } from \"./utils/route-parser\";\nimport { CacheOperations } from \"./types\";\n\n/**\n * Helper function to get the ID from an item\n * Checks both _id (MongoDB) and id (standard) fields\n */\nconst getItemId = (item: any): string | undefined => {\n  return item?._id || item?.id;\n};\n\n/**\n * Custom hook for cache operations\n * Provides functions to get, set, and manipulate cached data\n * @returns CacheOperations interface with all cache manipulation functions\n */\nconst useCache = (): CacheOperations => {\n  const dispatch = useDispatch();\n  const { auth: { customerId } } = useApp();\n  const cacheState = useSelector((state) => state.cache);\n\n  /**\n   * Parses a route and generates cache key with context\n   */\n  const getContext = useCallback(\n    (route: Route, variables?: Record<string, any>) => {\n      return parseRoute(route, variables, customerId);\n    },\n    [customerId]\n  );\n\n  /**\n   * Generates a cache key for a route and variables\n   */\n  const getKey = useCallback(\n    (route: Route, variables?: Record<string, any>) => {\n      const { key } = getContext(route, variables);\n      return key;\n    },\n    [getContext]\n  );\n\n  /**\n   * Gets cached data for a specific key\n   */\n  const getData = useCallback(\n    (key: string) => {\n      return cacheState[key];\n    },\n    [cacheState]\n  );\n\n  /**\n   * Sets cache data for a specific key\n   */\n  const setCache = useCallback(\n    (key: string, value: any) => {\n      dispatch(actions.set({ key, value }));\n    },\n    [dispatch]\n  );\n\n  /**\n   * Updates cache data (alias for setCache)\n   */\n  const update = useCallback(\n    (key: string, value: any) => {\n      setCache(key, value);\n    },\n    [setCache]\n  );\n\n  /**\n   * Updates a single item in a cached array\n   */\n  const updateItem = useCallback(\n    (key: string, id: string, value: any) => {\n      const cache = cacheState[key];\n      if (Array.isArray(cache)) {\n        const index = cache.findIndex((item: any) => getItemId(item) === id);\n        if (index !== -1) {\n          const updated = [...cache];\n          updated[index] = { ...updated[index], ...value };\n          setCache(key, updated);\n        }\n      }\n    },\n    [cacheState, setCache]\n  );\n\n  /**\n   * Gets a single item from a cached array\n   */\n  const getItem = useCallback(\n    (key: string, id: string) => {\n      const cache = cacheState[key];\n      if (Array.isArray(cache)) {\n        return cache.find((item: any) => getItemId(item) === id);\n      }\n      return undefined;\n    },\n    [cacheState]\n  );\n\n  /**\n   * Updates a single property in a cached object\n   */\n  const updateValue = useCallback(\n    (key: string, arg: string, value: any) => {\n      const cache = cacheState[key];\n      if (!Array.isArray(cache) && typeof cache === \"object\") {\n        setCache(key, { ...cache, [arg]: value });\n      }\n    },\n    [cacheState, setCache]\n  );\n\n  /**\n   * Updates multiple properties in a cached object\n   */\n  const updateValues = useCallback(\n    (key: string, values: Record<string, any>) => {\n      const cache = cacheState[key];\n      if (!Array.isArray(cache) && typeof cache === \"object\") {\n        setCache(key, { ...cache, ...values });\n      }\n    },\n    [cacheState, setCache]\n  );\n\n  /**\n   * Prepends data to the beginning of a cached array\n   */\n  const prepend = useCallback(\n    (key: string, data: any) => {\n      const cache = cacheState[key];\n      if (Array.isArray(cache)) {\n        setCache(key, [data, ...cache]);\n      } else {\n        setCache(key, [data]);\n      }\n    },\n    [cacheState, setCache]\n  );\n\n  /**\n   * Updates an item if it exists, or prepends it if it doesn't\n   */\n  const updateOrPrepend = useCallback(\n    (key: string, data: any) => {\n      const cache = cacheState[key];\n      if (Array.isArray(cache)) {\n        const dataId = getItemId(data);\n        const index = cache.findIndex((item: any) => getItemId(item) === dataId);\n        if (index !== -1) {\n          const updated = [...cache];\n          updated[index] = { ...updated[index], ...data };\n          setCache(key, updated);\n        } else {\n          setCache(key, [data, ...cache]);\n        }\n      } else {\n        setCache(key, [data]);\n      }\n    },\n    [cacheState, setCache]\n  );\n\n  /**\n   * Appends data to the end of a cached array\n   */\n  const append = useCallback(\n    (key: string, data: any) => {\n      const cache = cacheState[key];\n      if (Array.isArray(cache)) {\n        setCache(key, [...cache, data]);\n      } else {\n        setCache(key, [data]);\n      }\n    },\n    [cacheState, setCache]\n  );\n\n  /**\n   * Deletes an item from a cached array\n   */\n  const deleteItem = useCallback(\n    (key: string, id: string) => {\n      const cache = cacheState[key];\n      if (Array.isArray(cache)) {\n        setCache(key, cache.filter((item: any) => getItemId(item) !== id));\n      }\n    },\n    [cacheState, setCache]\n  );\n\n  /**\n   * Invalidates a specific cache entry\n   */\n  const invalidate = useCallback(\n    (key: string) => {\n      dispatch(actions.delete({ key }));\n    },\n    [dispatch]\n  );\n\n  /**\n   * Invalidates all queries matching a pattern\n   * @param pattern - String prefix or RegExp pattern\n   */\n  const invalidateQueries = useCallback(\n    (pattern: string | RegExp) => {\n      const regex =\n        typeof pattern === \"string\" ? new RegExp(`^${pattern}`) : pattern;\n\n      const keysToInvalidate = Object.keys(cacheState).filter((k) =>\n        regex.test(k)\n      );\n\n      keysToInvalidate.forEach((key) => {\n        dispatch(actions.delete({ key }));\n      });\n    },\n    [cacheState, dispatch]\n  );\n\n  /**\n   * Invalidates all cache entries\n   */\n  const invalidateAll = useCallback(() => {\n    dispatch(actions.clear());\n  }, [dispatch]);\n\n  return {\n    getItem,\n    setCache,\n    getKey,\n    getContext,\n    getData,\n    update,\n    updateValue,\n    updateValues,\n    updateItem,\n    deleteItem,\n    prepend,\n    append,\n    updateOrPrepend,\n    invalidate,\n    invalidateQueries,\n    invalidateAll,\n  };\n};\n\nexport default useCache;\n","const PATHS = {\n  login: 'POST:/Authenticate',\n  biometricAuth: 'POST:/TouchAuthenticate',\n  generateOtp: 'POST:/GenerateOTP',\n  validateOtp: 'POST:/ValidateOTP',\n  register: 'POST:/CreateNewAccount',\n  forgot: 'POST:/ForgotPassword',\n  getAccounts: 'GET:/GetAccounts/:customerId',\n  getTransferAccounts: 'GET:/GetTransferAccounts/:customerId',\n  getCustomer: 'GET:/GetCustomer/:customerId',\n  getBvnDetails: 'POST:/GetBVNDetails',\n  validateOTPBVN: 'POST:/ValidateOTPBVN',\n  registerDevice: 'POST:/RegisterDeviceUUID/:customerId',\n  accountStatement: 'POST:/GetAccountStatement/:customerId/:accountNumber',\n  loanHistory: 'POST:/GetLoanHistory/:customerId',\n  customerSummary: 'GET:/GetCustomerSummary/:customerId',\n  accountHistory: 'POST:/GetAccountHistory/:customerId/:accountNumber',\n  downloadStatement: 'POST:/DownloadAccountStatement/:customerId/:accountNumber',\n  changePassword: 'POST:/ChangePassword/:customerId',\n  changePin: 'POST:/SaveSecurityPin/:customerId',\n  deleteBeneficiary: 'POST:/DeleteBeneficiary/:customerId',\n  addBeneficiary: 'POST:/AddBeneficiary/:customerId',\n  getBeneficiaries: 'GET:/GetBeneficiary/:customerId',\n  confirmBeneficiary: 'POST:/ConfirmBeneficiary/:customerId',\n  getBanks: 'POST:/GetBanks',\n  transferHistory: 'POST:/GetRecentTransfer/:customerId',\n  transferBeneficiary: 'POST:/TransferFunds/:customerId',\n  transfer: 'POST:/TransferFundsMixed/:customerId',\n  airtime: 'POST:/PayAirtimeBills/:customerId',\n  bill: 'POST:/PayBills/:customerId',\n  billHistory: 'POST:/GetBillHistory/:customerId',\n  billerCategories: 'GET:/GetBillerCategory/:customerId',\n  billers: 'POST:/GetBillers/:customerId',\n  billerProduct: 'POST:/GetProducts/:customerId',\n  validateBillCustomer: 'POST:/ValidateBillCustomer/:customerId',\n  getDeposit: 'GET:/GetDeposits/:customerId',\n  getSavings: 'GET:/GetSavings/:customerId',\n  createSavings: 'POST:/AddNewTargetSavings/:customerId',\n  getLoans: 'GET:/GetLoans/:customerId',\n  liqudateDeposit: 'POST:/LiqudateDeposit/:customerId',\n  getInvestmentRate: 'POST:/GetInvestmentRate/:customerId',\n  createDeposit: 'POST:/BookDeposits/:customerId',\n  getCards: 'POST:/GetCards/:customerId',\n  fundWallet: 'POST:/FundSavings/:customerId',\n  requestLoan: 'POST:/LoanRequest/:customerId',\n  calculateLTV: 'GET:/CalculateLTV/:customerId',\n  updateSavings: 'POST:/UpdateSavings/:customerId',\n  closeSavings: 'POST:/CloseSavings/:customerId',\n  savings: 'GET:/savings/:itemId',\n  savingsWithdrawal: 'POST:/WithdrawSavings/:customerId',\n  registerToken: 'POST:/AddFirebaseDetails/:customerId',\n  feedback: 'POST:/SendFeedback/:customerId',\n  blockCard: 'POST:/BlockCard/:customerId',\n  requestCard: 'POST:/RequestCard/:customerId',\n  verifyNin: 'POST:/VerifyNIN/:customerId',\n  updateLocationId: 'POST:/updateLocationId/:customerId',\n};\nexport default PATHS;\n","import { Route } from \"../../types\";\nimport { Method } from \"../../utils/service\";\nimport PATHS from \"../../paths\";\n\nexport interface ParsedRoute {\n  path: string;\n  method: Method;\n  key: string;\n  rawPath: string;\n}\n\n/**\n * Parses a route string and replaces path parameters with actual values\n * @param route - The route key from PATHS or a raw route string\n * @param variables - Object containing path parameters and query variables\n * @param customerId - The customer ID to inject into paths\n * @returns ParsedRoute object with path, method, key, and rawPath\n */\nexport function parseRoute(\n  route: Route,\n  variables: Record<string, any> = {},\n  customerId?: string\n): ParsedRoute {\n  const rawPath = PATHS[route] || route;\n  const [method, pathTemplate] = rawPath.split(\":/\");\n  \n  // Clone variables to avoid mutation\n  const variablesCopy = { ...variables };\n  \n  // Replace path parameters\n  const path = \"/\" + pathTemplate.replace(/:\\w+/g, (matched: string) => {\n    const params = { customerId, ...variablesCopy };\n    const paramName = matched.replace(/\\W/g, \"\");\n    \n    // Remove from variables copy so it's not added to query string\n    delete variablesCopy[paramName];\n    \n    return params[paramName as keyof typeof params] || matched;\n  });\n  \n  // Generate cache key\n  const key = path + JSON.stringify(variablesCopy);\n  \n  return {\n    path,\n    method: (method as Method) || \"GET\",\n    key,\n    rawPath,\n  };\n}\n\n/**\n * Generates a cache key for a given route and variables\n * @param route - The route key from PATHS\n * @param variables - Object containing route variables\n * @param customerId - The customer ID\n * @returns Cache key string\n */\nexport function generateCacheKey(\n  route: Route,\n  variables: Record<string, any> = {},\n  customerId?: string\n): string {\n  const { key } = parseRoute(route, variables, customerId);\n  return key;\n}\n\n","/**\n * Hook-related constants\n */\n\n/**\n * Network request timeout in milliseconds\n */\nexport const NETWORK_TIMEOUT = 10000; // 10 seconds\n\n/**\n * Default error messages\n */\nexport const ERROR_MESSAGES = {\n  GENERIC: \"Oops! an error occurred\",\n  NETWORK: \"Network error occurred\",\n  TIMEOUT: \"Request timed out\",\n  SESSION_EXPIRED: \"Session expired! kindly login\",\n  UNAUTHORIZED: \"Unauthorized access\",\n} as const;\n\n/**\n * HTTP status codes\n */\nexport const STATUS_CODES = {\n  OK: 200,\n  CREATED: 201,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  SERVER_ERROR: 500,\n} as const;\n\n/**\n * Cache TTL constants\n */\nexport const DEFAULT_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\nexport const DEFAULT_STALE_TIME = 0; // immediately stale (always refetch)\nexport const MAX_CACHE_SIZE = 100; // LRU limit\n\n/**\n * Network policies for queries\n */\nexport type NetworkPolicy =\n  | \"network-and-cache\"\n  | \"cache-only\"\n  | \"network-only\"\n  | \"cache-first\"\n  | \"stale-while-revalidate\"; // NEW\n\n/**\n * Concat strategies for fetchMore\n */\nexport type ConcatStrategy = \"start\" | \"end\" | \"pagination\";\n\n","/**\n * Standard error response structure\n */\nexport interface ErrorResponse {\n  error: string;\n  status?: number;\n}\n\n/**\n * Standard success response structure\n */\nexport interface SuccessResponse<T = any> {\n  data: T;\n  status: number;\n}\n\n/**\n * Combined response type\n */\nexport type ApiResponse<T = any> = ErrorResponse | SuccessResponse<T>;\n\n/**\n * Extracts error message from various response formats\n * @param response - The API response object\n * @param defaultMessage - Default error message if none found\n * @returns Error message string\n */\nexport function extractErrorMessage(\n  response: any,\n  defaultMessage: string = \"Oops! an error occurred\"\n): string {\n  if (typeof response === \"string\") {\n    return response;\n  }\n  \n  // Try common error paths\n  return (\n    response?.data?.data?.ResponseDescription ||\n    response?.data?.ResponseDescription ||\n    response?.data?.error ||\n    response?.error ||\n    response?.message ||\n    defaultMessage\n  );\n}\n\n/**\n * Checks if the response status indicates success\n * @param status - HTTP status code\n * @returns True if successful status code\n */\nexport function isSuccessStatus(status: number): boolean {\n  return [200, 201].includes(status);\n}\n\n/**\n * Checks if the response status indicates unauthorized/not found\n * @param status - HTTP status code\n * @returns True if status is 401 or 404\n */\nexport function isAuthError(status: number): boolean {\n  return [401, 404].includes(status);\n}\n\n/**\n * Creates a standardized error response\n * @param error - Error message or Error object\n * @param status - HTTP status code\n * @returns ErrorResponse object\n */\nexport function createErrorResponse(\n  error: string | Error,\n  status: number = 500\n): ErrorResponse {\n  const message = typeof error === \"string\" ? error : error.message;\n  return {\n    error: message || \"Oops! an error occurred\",\n    status,\n  };\n}\n\n/**\n * Creates a standardized success response\n * @param data - Response data\n * @param status - HTTP status code\n * @returns SuccessResponse object\n */\nexport function createSuccessResponse<T>(\n  data: T,\n  status: number = 200\n): SuccessResponse<T> {\n  return {\n    data,\n    status,\n  };\n}\n\n/**\n * Checks if an error is an abort/cancellation error\n * @param error - The error to check\n * @returns True if the error is from request cancellation\n */\nexport function isAbortError(error: any): boolean {\n  if (!error) return false;\n\n  return (\n    error.name === \"AbortError\" ||\n    error.name === \"CanceledError\" ||\n    error.code === \"ERR_CANCELED\" ||\n    error.message?.includes(\"abort\") ||\n    error.message?.includes(\"cancel\")\n  );\n}\n\n/**\n * Checks if an error is a cancellation error (alias for isAbortError)\n * @param error - The error to check\n * @returns True if the error is from request cancellation\n */\nexport function isCancelError(error: any): boolean {\n  return isAbortError(error);\n}\n\n/**\n * Determines if a request should be retried based on the error\n * @param error - The error to check\n * @returns True if the request should be retried\n */\nexport function shouldRetry(error: any): boolean {\n  // Don't retry if it was cancelled\n  if (isAbortError(error)) {\n    return false;\n  }\n\n  // Don't retry client errors (4xx)\n  if (error.response?.status >= 400 && error.response?.status < 500) {\n    return false;\n  }\n\n  // Don't retry auth errors\n  if (isAuthError(error.response?.status)) {\n    return false;\n  }\n\n  // Retry on network errors or 5xx server errors\n  return true;\n}\n\n","/**\n * Request Deduplication System\n * Prevents duplicate in-flight requests with the same key\n * All components requesting the same data share the same Promise\n */\n\nconst inFlightRequests = new Map<string, Promise<any>>();\n\n/**\n * Gets an existing in-flight request or creates a new one\n * @param key - Unique identifier for the request\n * @param requestFn - Function that performs the actual request\n * @returns Promise that resolves with the request result\n * \n * @example\n * const result = await getOrCreateRequest('users-123', () => \n *   http('/users/123', 'GET')\n * );\n */\nexport function getOrCreateRequest<T>(\n  key: string,\n  requestFn: () => Promise<T>\n): Promise<T> {\n  // Check if request is already in flight\n  if (inFlightRequests.has(key)) {\n    return inFlightRequests.get(key)!;\n  }\n\n  // Create new request and store it\n  const promise = requestFn()\n    .finally(() => {\n      // Clean up after request completes (success or error)\n      inFlightRequests.delete(key);\n    });\n\n  inFlightRequests.set(key, promise);\n  return promise;\n}\n\n/**\n * Manually cancel/remove a request from the in-flight queue\n * Useful when aborting a request\n * @param key - The request key to cancel\n */\nexport function cancelRequest(key: string): void {\n  inFlightRequests.delete(key);\n}\n\n/**\n * Check if a request is currently in flight\n * @param key - The request key to check\n * @returns True if request is in progress\n */\nexport function isRequestInFlight(key: string): boolean {\n  return inFlightRequests.has(key);\n}\n\n/**\n * Get the number of in-flight requests\n * Useful for debugging and monitoring\n */\nexport function getInFlightCount(): number {\n  return inFlightRequests.size;\n}\n\n/**\n * Clear all in-flight requests\n * Useful for testing or when resetting application state\n */\nexport function clearAllRequests(): void {\n  inFlightRequests.clear();\n}\n\n","/**\n * Cache Helper Utilities\n * Functions for validating cache freshness, expiry, and staleness\n */\n\nimport { CacheEntry } from \"../../store/reducers/cache-reducer\";\n\n/**\n * Checks if a cache entry has expired based on its TTL\n * @param entry - The cache entry to check\n * @returns True if the cache has expired\n * \n * @example\n * const entry = { data: {...}, timestamp: Date.now(), expiresAt: Date.now() - 1000 };\n * isCacheExpired(entry); // true\n */\nexport function isCacheExpired(entry: CacheEntry | any): boolean {\n  // Handle backward compatibility - check if entry is a CacheEntry\n  if (!entry || typeof entry !== 'object') {\n    return false;\n  }\n  \n  // If it's a new-style entry with expiresAt\n  if ('expiresAt' in entry && entry.expiresAt) {\n    return Date.now() > entry.expiresAt;\n  }\n  \n  // Old-style entries never expire\n  return false;\n}\n\n/**\n * Checks if a cache entry is stale and should be refetched\n * @param entry - The cache entry to check\n * @returns True if the cache is stale\n * \n * @example\n * const entry = { data: {...}, timestamp: Date.now(), staleAt: Date.now() - 1000 };\n * isCacheStale(entry); // true\n */\nexport function isCacheStale(entry: CacheEntry | any): boolean {\n  // Handle backward compatibility\n  if (!entry || typeof entry !== 'object') {\n    return true; // No cache = stale\n  }\n  \n  // If it's a new-style entry with staleAt\n  if ('staleAt' in entry) {\n    // If staleAt is undefined, never stale (infinite fresh time)\n    if (entry.staleAt === undefined) {\n      return false;\n    }\n    return Date.now() > entry.staleAt;\n  }\n  \n  // Old-style entries are always considered stale (safe default)\n  return true;\n}\n\n/**\n * Checks if a cache entry is fresh (not expired and not stale)\n * @param entry - The cache entry to check\n * @returns True if the cache is fresh\n * \n * @example\n * const entry = { \n *   data: {...}, \n *   timestamp: Date.now(), \n *   expiresAt: Date.now() + 10000,\n *   staleAt: Date.now() + 5000\n * };\n * isCacheFresh(entry); // true\n */\nexport function isCacheFresh(entry: CacheEntry | any): boolean {\n  return !isCacheExpired(entry) && !isCacheStale(entry);\n}\n\n/**\n * Extracts data from a cache entry, handling both new and old formats\n * @param entry - The cache entry\n * @returns The actual data\n */\nexport function getCacheData(entry: CacheEntry | any): any {\n  if (!entry) {\n    return undefined;\n  }\n  \n  // New-style entry with 'data' property\n  if ('data' in entry && 'timestamp' in entry) {\n    return entry.data;\n  }\n  \n  // Old-style entry (data is the entry itself)\n  return entry;\n}\n\n/**\n * Creates a cache entry with TTL and stale time\n * @param data - The data to cache\n * @param ttl - Time to live in milliseconds (optional)\n * @param staleTime - Time until stale in milliseconds (optional)\n * @returns A properly formatted cache entry\n */\nexport function createCacheEntry(\n  data: any,\n  ttl?: number,\n  staleTime?: number\n): CacheEntry {\n  const timestamp = Date.now();\n  return {\n    data,\n    timestamp,\n    expiresAt: ttl ? timestamp + ttl : undefined,\n    staleAt: staleTime !== undefined ? timestamp + staleTime : undefined,\n  };\n}\n\n/**\n * Gets the age of a cache entry in milliseconds\n * @param entry - The cache entry\n * @returns Age in milliseconds\n */\nexport function getCacheAge(entry: CacheEntry | any): number {\n  if (!entry || !entry.timestamp) {\n    return Infinity;\n  }\n  return Date.now() - entry.timestamp;\n}\n\n/**\n * Checks if cache entry exists and is not expired\n * @param entry - The cache entry\n * @returns True if cache can be used\n */\nexport function canUseCache(entry: CacheEntry | any): boolean {\n  return entry && !isCacheExpired(entry);\n}\n\n","import http, { Method } from \"../utils/service\";\nimport { useApp } from \"../store/contexts/app-context\";\nimport useDispatch from \"./use-dispatch\";\nimport { actions } from \"../store/reducers/cache-reducer\";\nimport * as network from \"../store/reducers/thread-reducer\";\nimport useCache from \"./use-cache\";\nimport { Route } from \"../types\";\nimport { MutationResponse } from \"./types\";\nimport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  isAbortError,\n  createErrorResponse,\n  createSuccessResponse,\n} from \"./utils/error-handler\";\n\n/**\n * Options for async query\n */\ninterface UseQueryAsyncOptions {\n  authToken?: string;\n  signal?: AbortSignal;\n}\n\n/**\n * Hook return type - a function that performs async queries\n */\ntype UseQueryAsyncReturn = (\n  route: Route,\n  variables?: Record<string, any>,\n  options?: UseQueryAsyncOptions | string // string for backward compatibility (authToken)\n) => Promise<MutationResponse>;\n\n/**\n * Custom hook for async data fetching without subscriptions\n * Useful for one-time data fetches that update the cache\n * @returns An async function to fetch data\n */\nconst useQueryAsync = (): UseQueryAsyncReturn => {\n  const app = useApp();\n  const { auth } = app;\n  const { getContext } = useCache();\n  const dispatch = useDispatch();\n\n  /**\n   * Performs an async query and updates cache and loading state\n   * @param route - The API route key\n   * @param variables - Query variables\n   * @param options - Optional auth token or options object with signal\n   * @returns Promise with response data or error\n   */\n  return async (\n    route: Route,\n    variables: Record<string, any> = {},\n    options?: UseQueryAsyncOptions | string\n  ): Promise<MutationResponse> => {\n    const { key, method, path } = getContext(route, variables);\n    \n    // Handle backward compatibility (authToken as string)\n    const opts: UseQueryAsyncOptions = \n      typeof options === 'string' \n        ? { authToken: options }\n        : options || {};\n    \n    try {\n      // Set loading state\n      dispatch(\n        network.actions.set({\n          key,\n          value: {\n            loading: true,\n            error: undefined,\n          },\n        })\n      );\n\n      // Perform the request\n      const res: any = await http(\n        path,\n        (method as Method) || \"GET\",\n        variables,\n        {\n          returnStatus: true,\n          auth: opts.authToken || auth.accessToken,\n          signal: opts.signal,\n        }\n      );\n\n      const error = !isSuccessStatus(res.status)\n        ? extractErrorMessage(res)\n        : undefined;\n\n      // Update loading/error state\n      dispatch(\n        network.actions.set({\n          key,\n          value: {\n            loading: false,\n            error,\n          },\n        })\n      );\n\n      if (isSuccessStatus(res.status)) {\n        // Update cache with successful data\n        dispatch(actions.set({ key, value: res.data.data }));\n        return createSuccessResponse(res.data.data, res.status);\n      } else if (isAuthError(res.status)) {\n        // Handle auth errors\n        app.setTimeout().catch(() => {});\n        return createErrorResponse(error || \"Unauthorized\", res.status);\n      }\n      \n      return createErrorResponse(error || \"Request failed\", res.status);\n    } catch (e: any) {\n      // Handle abort errors differently - don't update state\n      if (isAbortError(e)) {\n        dispatch(\n          network.actions.set({\n            key,\n            value: {\n              loading: false,\n              error: undefined,\n            },\n          })\n        );\n        return createErrorResponse(\"Request cancelled\", 0);\n      }\n      \n      const error = e.message || \"Oops! an error occurred\";\n      \n      // Update error state\n      dispatch(\n        network.actions.set({\n          key,\n          value: {\n            loading: false,\n            error,\n          },\n        })\n      );\n      \n      return createErrorResponse(error, 500);\n    }\n  };\n};\n\nexport default useQueryAsync;\n","import { useState, useCallback, useRef, useEffect } from \"react\";\nimport http, { Method } from \"../utils/service\";\nimport { useApp } from \"../store/contexts/app-context\";\nimport { Keyboard } from \"react-native\";\nimport { Route } from \"../types\";\nimport useCache from \"./use-cache\";\nimport { MutationOptions, MutationResult, MutationResponse } from \"./types\";\nimport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  isAbortError,\n  createErrorResponse,\n  createSuccessResponse,\n} from \"./utils/error-handler\";\nimport { ERROR_MESSAGES } from \"./constants\";\n\n/**\n * Custom hook for data mutations (POST, PUT, DELETE operations)\n * @param route - The API route key\n * @param option - Mutation options (keyboard dismiss, text response)\n * @returns MutationResult with mutate function, loading state, error, and data\n */\nconst useMutation = <T = any,>(\n  route: Route,\n  option?: MutationOptions\n): MutationResult<T> => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | undefined>(undefined);\n  const [data, setData] = useState<T | undefined>(undefined);\n\n  const app = useApp();\n  const { auth } = app;\n  const { getContext } = useCache();\n  \n  // Store abort controller for request cancellation\n  const abortControllerRef = useRef<AbortController | null>(null);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  /**\n   * Performs the mutation request\n   * @param variables - Request variables\n   * @returns Promise with response data or error\n   */\n  const mutate = useCallback(\n    async (variables: Record<string, any>): Promise<MutationResponse<T>> => {\n      try {\n        // Dismiss keyboard by default\n        if (option?.keyboard === undefined || option?.keyboard) {\n          Keyboard.dismiss();\n        }\n\n        const { path, method, rawPath } = getContext(route, variables);\n        \n        // Abort any existing request\n        if (abortControllerRef.current) {\n          abortControllerRef.current.abort();\n        }\n        \n        // Create new abort controller\n        abortControllerRef.current = new AbortController();\n        \n        setLoading(true);\n        setError(undefined);\n\n        const res: any = await http(\n          path,\n          (method as Method) || \"POST\",\n          variables,\n          {\n            returnStatus: true,\n            auth: auth?.accessToken,\n            returnText: option?.text,\n            signal: abortControllerRef.current.signal,\n          }\n        );\n\n        if (isSuccessStatus(res.status)) {\n          const responseData = res.data.data;\n          setData(responseData);\n          setLoading(false);\n          return createSuccessResponse(responseData, res.status);\n        }\n\n        let errorMessage = extractErrorMessage(res);\n\n        // Check for auth errors\n        if (rawPath.includes(\":customerId\") && isAuthError(res.status)) {\n          errorMessage = ERROR_MESSAGES.SESSION_EXPIRED;\n          await app.setTimeout();\n        }\n\n        setError(errorMessage);\n        setLoading(false);\n        return createErrorResponse(errorMessage, res.status);\n      } catch (e: any) {\n        // Handle abort errors - don't set error state for cancellations\n        if (isAbortError(e)) {\n          setLoading(false);\n          return createErrorResponse(\"Request cancelled\", 0);\n        }\n        \n        setLoading(false);\n        const errorMessage = e.message || ERROR_MESSAGES.GENERIC;\n        setError(errorMessage);\n        return createErrorResponse(errorMessage, 500);\n      }\n    },\n    [route, option, auth, app, getContext]\n  );\n  \n  /**\n   * Cancels the current mutation request\n   */\n  const cancel = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  return [\t\n    mutate,\n    {\n      loading,\n      error,\n      data,\n      cancel,\n    }\n  ];\n};\n\nexport default useMutation;\n","import { useState, useCallback, useRef, useEffect } from \"react\";\nimport http from \"../utils/service\";\nimport { useApp } from \"../store/contexts/app-context\";\nimport { Keyboard } from \"react-native\";\nimport { Route } from \"../types\";\nimport useCache from \"./use-cache\";\nimport { MutationOptions, MutationResult, MutationResponse } from \"./types\";\nimport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  isAbortError,\n  createErrorResponse,\n  createSuccessResponse,\n} from \"./utils/error-handler\";\nimport { ERROR_MESSAGES } from \"./constants\";\n\n/**\n * Custom hook for async mutations with extended functionality\n * Unlike useMutation, this version uses route string directly (legacy support)\n * @param route - The raw API route string (e.g., \"POST:/endpoint/:param\")\n * @param option - Mutation options (keyboard dismiss)\n * @returns MutationResult with mutate function, loading state, error, and data\n */\nconst useMutationAsync = <T = any,>(\n  route: string,\n  option?: MutationOptions\n): MutationResult<T> => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | undefined>(undefined);\n  const [data, setData] = useState<T | undefined>(undefined);\n  \n  const app = useApp();\n  const { auth } = app;\n  \n  // Store abort controller for request cancellation\n  const abortControllerRef = useRef<AbortController | null>(null);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  /**\n   * Performs the mutation request\n   * @param variables - Request variables\n   * @returns Promise with response data or error\n   */\n  const mutate = useCallback(\n    async (variables: Record<string, any>): Promise<MutationResponse<T>> => {\n      try {\n        // Dismiss keyboard by default\n        if (option?.keyboard === undefined || option?.keyboard) {\n          Keyboard.dismiss();\n        }\n\n        // Parse route manually (legacy format support)\n        const [method, pathTemplate] = route.split(\":/\");\n        const variablesCopy = { ...variables };\n        \n        const path = \"/\" + pathTemplate.replace(/:\\w+/g, (matched: string) => {\n          const paramName = matched.replace(/\\W/g, \"\");\n          const value = variablesCopy[paramName];\n          delete variablesCopy[paramName];\n          return value || matched;\n        });\n\n        // Abort any existing request\n        if (abortControllerRef.current) {\n          abortControllerRef.current.abort();\n        }\n        \n        // Create new abort controller\n        abortControllerRef.current = new AbortController();\n        \n        setLoading(true);\n        setError(undefined);\n\n        const res: any = await http(\n          path,\n          (method as any) || \"POST\",\n          variablesCopy,\n          {\n            returnStatus: true,\n            auth: auth.accessToken,\n            signal: abortControllerRef.current.signal,\n          }\n        );\n\n        if (isSuccessStatus(res.status)) {\n          const responseData = res.data.data;\n          setData(responseData);\n          setLoading(false);\n          return createSuccessResponse(responseData, res.status);\n        }\n\n        // Check for auth errors (avoid login route check)\n        if (isAuthError(res.status)) {\n          await app.setTimeout();\n        }\n\n        const errorMessage = extractErrorMessage(res);\n        setError(errorMessage);\n        setLoading(false);\n        return createErrorResponse(errorMessage, res.status);\n      } catch (e: any) {\n        // Handle abort errors - don't set error state for cancellations\n        if (isAbortError(e)) {\n          setLoading(false);\n          return createErrorResponse(\"Request cancelled\", 0);\n        }\n        \n        setLoading(false);\n        const errorMessage = e.message || ERROR_MESSAGES.GENERIC;\n        setError(errorMessage);\n        return createErrorResponse(errorMessage, 500);\n      }\n    },\n    [route, option, auth, app]\n  );\n  \n  /**\n   * Cancels the current mutation request\n   */\n  const cancel = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  return [\n    mutate,\n    {\n      loading,\n      error,\n      data,\n      cancel,\n    }\n  ];\n};\n\nexport default useMutationAsync;\n","/**\n * HTTP Helper Utilities\n * Provides utilities for managing AbortControllers, checking error types,\n * and formatting request data\n */\n\n/**\n * Creates a new AbortController for request cancellation\n * @returns New AbortController instance\n * \n * @example\n * const controller = createAbortController();\n * http('/api/data', 'GET', {}, { signal: controller.signal });\n * // Later: controller.abort();\n */\nexport const createAbortController = (): AbortController => {\n  return new AbortController();\n};\n\n/**\n * Checks if an error is an abort/cancellation error\n * @param error - The error to check\n * @returns True if the error is from request cancellation\n * \n * @example\n * try {\n *   await http('/api/data', 'GET', {}, { signal: controller.signal });\n * } catch (error) {\n *   if (isAbortError(error)) {\n *     console.log('Request was cancelled');\n *   }\n * }\n */\nexport const isAbortError = (error: any): boolean => {\n  if (!error) return false;\n  \n  return (\n    error.name === 'AbortError' ||\n    error.name === 'CanceledError' ||\n    error.code === 'ERR_CANCELED' ||\n    error.message?.includes('abort') ||\n    error.message?.includes('cancel')\n  );\n};\n\n/**\n * Checks if an error is a cancellation error (alias for isAbortError)\n * @param error - The error to check\n * @returns True if the error is from request cancellation\n */\nexport const isCancelError = (error: any): boolean => {\n  return isAbortError(error);\n};\n\n/**\n * Determines if a request should be retried based on the error\n * @param error - The error to check\n * @returns True if the request should be retried\n * \n * @example\n * try {\n *   await http('/api/data', 'GET', {});\n * } catch (error) {\n *   if (shouldRetry(error)) {\n *     // Retry the request\n *   }\n * }\n */\nexport const shouldRetry = (error: any): boolean => {\n  // Don't retry if it was cancelled\n  if (isAbortError(error)) {\n    return false;\n  }\n\n  // Don't retry client errors (4xx)\n  if (error.response?.status >= 400 && error.response?.status < 500) {\n    return false;\n  }\n\n  // Retry on network errors or 5xx server errors\n  return true;\n};\n\n/**\n * Converts an object to FormData for multipart/form-data requests\n * @param data - Object to convert\n * @returns FormData instance\n * \n * @example\n * const formData = formatFormData({ name: 'John', age: 30 });\n * http('/api/upload', 'POST', formData, { contentType: 'multipart' });\n */\nexport const formatFormData = (data: Record<string, any>): FormData => {\n  const formData = new FormData();\n  \n  for (const key in data) {\n    if (data.hasOwnProperty(key)) {\n      const value = data[key];\n      \n      // Handle different types appropriately\n      if (value !== null && value !== undefined) {\n        formData.append(key, value);\n      }\n    }\n  }\n  \n  return formData;\n};\n\n/**\n * Converts an object to URL-encoded string for application/x-www-form-urlencoded requests\n * @param data - Object to convert\n * @returns URL-encoded string\n * \n * @example\n * const encoded = formatUrlEncoded({ name: 'John Doe', age: 30 });\n * // Returns: \"name=John%20Doe&age=30\"\n */\nexport const formatUrlEncoded = (data: Record<string, any>): string => {\n  const formBody: string[] = [];\n  \n  for (const property in data) {\n    if (data.hasOwnProperty(property)) {\n      const value = data[property];\n      \n      // Skip null/undefined values\n      if (value !== null && value !== undefined) {\n        const encodedKey = encodeURIComponent(property);\n        const encodedValue = encodeURIComponent(value);\n        formBody.push(`${encodedKey}=${encodedValue}`);\n      }\n    }\n  }\n  \n  return formBody.join('&');\n};\n\n/**\n * Safely aborts an AbortController if it exists\n * @param controller - The AbortController to abort\n * \n * @example\n * const controller = createAbortController();\n * // Later...\n * safeAbort(controller);\n */\nexport const safeAbort = (controller: AbortController | null | undefined): void => {\n  if (controller && !controller.signal.aborted) {\n    controller.abort();\n  }\n};\n\n/**\n * Creates a timeout-based AbortController\n * @param timeoutMs - Timeout in milliseconds\n * @returns Object with controller and cleanup function\n * \n * @example\n * const { controller, cleanup } = createTimeoutController(5000);\n * try {\n *   await http('/api/data', 'GET', {}, { signal: controller.signal });\n * } finally {\n *   cleanup();\n * }\n */\nexport const createTimeoutController = (\n  timeoutMs: number\n): { controller: AbortController; cleanup: () => void } => {\n  const controller = new AbortController();\n  \n  const timeoutId = setTimeout(() => {\n    controller.abort();\n  }, timeoutMs);\n  \n  const cleanup = () => {\n    clearTimeout(timeoutId);\n  };\n  \n  return { controller, cleanup };\n};\n\n/**\n * Combines multiple AbortSignals into one\n * When any signal is aborted, the combined signal is aborted\n * @param signals - Array of AbortSignals to combine\n * @returns Combined AbortController\n * \n * @example\n * const userController = createAbortController();\n * const timeoutController = createTimeoutController(5000);\n * const combined = combineAbortSignals([userController.signal, timeoutController.signal]);\n * await http('/api/data', 'GET', {}, { signal: combined.signal });\n */\nexport const combineAbortSignals = (signals: AbortSignal[]): AbortController => {\n  const controller = new AbortController();\n  \n  for (const signal of signals) {\n    if (signal.aborted) {\n      controller.abort();\n      break;\n    }\n    \n    signal.addEventListener('abort', () => {\n      controller.abort();\n    }, { once: true });\n  }\n  \n  return controller;\n};\n\n","/**\n * Debug Logger for Query/Mutation Hooks\n * Provides detailed logging for debugging cache hits, network requests, and timing\n */\n\nexport interface QueryDebugInfo {\n  key: string;\n  action: 'cache-hit' | 'cache-miss' | 'fetch-start' | 'fetch-success' | 'fetch-error' | 'invalidate';\n  timestamp: number;\n  duration?: number;\n  data?: any;\n  error?: any;\n  variables?: any;\n}\n\n/**\n * Query Debugger Class\n * Provides structured logging for debugging data fetching\n */\nexport class QueryDebugger {\n  private enabled: boolean;\n  private prefix: string;\n\n  constructor(enabled: boolean, prefix: string = '[Query]') {\n    this.enabled = enabled;\n    this.prefix = prefix;\n  }\n\n  /**\n   * Log a cache hit\n   */\n  logCacheHit(key: string, data: any) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} ðŸŽ¯ Cache HIT`, {\n      key,\n      dataSize: this.getDataSize(data),\n      timestamp: new Date().toISOString(),\n    });\n\n    if (data) {\n      console.log(`${this.prefix} Data:`, data);\n    }\n  }\n\n  /**\n   * Log a cache miss\n   */\n  logCacheMiss(key: string) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} âŒ Cache MISS`, {\n      key,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log the start of a fetch request\n   */\n  logFetchStart(key: string, variables?: any) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} ðŸš€ Fetching`, {\n      key,\n      variables,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log a successful fetch\n   */\n  logFetchSuccess(key: string, duration?: number, data?: any) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} âœ… Success`, {\n      key,\n      duration: duration ? `${duration.toFixed(2)}ms` : 'N/A',\n      dataSize: this.getDataSize(data),\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log a fetch error\n   */\n  logFetchError(key: string, error: any, duration?: number) {\n    if (!this.enabled) return;\n\n    console.error(`${this.prefix} âŒ Error`, {\n      key,\n      error: error?.message || error,\n      duration: duration ? `${duration.toFixed(2)}ms` : 'N/A',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log cache invalidation\n   */\n  logInvalidate(key: string | RegExp) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} ðŸ”„ Invalidating`, {\n      pattern: key.toString(),\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log network policy decision\n   */\n  logPolicy(key: string, policy: string, decision: string) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} ðŸ“‹ Policy`, {\n      key,\n      policy,\n      decision,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log cache expiry check\n   */\n  logCacheExpiry(key: string, isExpired: boolean, isStale: boolean) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} â° Cache Status`, {\n      key,\n      expired: isExpired,\n      stale: isStale,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log request deduplication\n   */\n  logDeduplication(key: string, isDuplicate: boolean) {\n    if (!this.enabled) return;\n\n    if (isDuplicate) {\n      console.log(`${this.prefix} ðŸ”— Request Deduplicated`, {\n        key,\n        message: 'Using existing in-flight request',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  /**\n   * Get the size of data (array length or object keys)\n   */\n  private getDataSize(data: any): string {\n    if (!data) return '0';\n    if (Array.isArray(data)) return `${data.length} items`;\n    if (typeof data === 'object') return `${Object.keys(data).length} keys`;\n    return 'scalar';\n  }\n}\n\n/**\n * Global debug toggle\n * Can be enabled at runtime for debugging\n */\nlet globalDebugEnabled = false;\n\nexport function enableGlobalDebug() {\n  globalDebugEnabled = true;\n}\n\nexport function disableGlobalDebug() {\n  globalDebugEnabled = false;\n}\n\nexport function isGlobalDebugEnabled(): boolean {\n  return globalDebugEnabled;\n}\n\n/**\n * Create a debugger instance\n */\nexport function createDebugger(enabled?: boolean, prefix?: string): QueryDebugger {\n  return new QueryDebugger(enabled ?? globalDebugEnabled, prefix);\n}\n\n","/**\n * Retry Manager with Exponential Backoff\n * Provides intelligent retry logic for failed requests\n */\n\nimport { shouldRetry as shouldRetryError } from \"./error-handler\";\n\nexport interface RetryOptions {\n  retries: number;\n  delay: number | 'exponential';\n  condition?: (error: any) => boolean;\n  maxDelay?: number;\n}\n\n/**\n * Retries a function with exponential backoff\n * @param fn - The function to retry\n * @param options - Retry configuration\n * @returns Promise that resolves when function succeeds or retries are exhausted\n * \n * @example\n * const data = await retryWithBackoff(\n *   () => http('/api/data', 'GET'),\n *   { retries: 3, delay: 'exponential' }\n * );\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions\n): Promise<T> {\n  const { retries, delay, condition, maxDelay = 30000 } = options;\n  let lastError: any;\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      // Check custom condition if provided\n      if (condition && !condition(error)) {\n        throw error;\n      }\n\n      // Check if error is retryable\n      if (!shouldRetryError(error)) {\n        throw error;\n      }\n\n      // Don't wait after last attempt\n      if (attempt === retries) {\n        throw error;\n      }\n\n      // Calculate delay\n      const waitTime = calculateDelay(delay, attempt, maxDelay);\n\n      // Wait before next attempt\n      await sleep(waitTime);\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Calculate delay based on strategy\n */\nfunction calculateDelay(\n  delay: number | 'exponential',\n  attempt: number,\n  maxDelay: number\n): number {\n  if (delay === 'exponential') {\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (capped)\n    return Math.min(1000 * Math.pow(2, attempt), maxDelay);\n  }\n  return delay;\n}\n\n/**\n * Sleep utility\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Retry with jitter (adds randomness to prevent thundering herd)\n */\nexport async function retryWithJitter<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions & { jitter?: number }\n): Promise<T> {\n  const { jitter = 0.1, ...retryOptions } = options;\n\n  return retryWithBackoff(fn, {\n    ...retryOptions,\n    delay:\n      typeof retryOptions.delay === 'number'\n        ? addJitter(retryOptions.delay, jitter)\n        : retryOptions.delay,\n  });\n}\n\n/**\n * Adds random jitter to delay\n */\nfunction addJitter(delay: number, jitterFactor: number): number {\n  const jitter = delay * jitterFactor * Math.random();\n  return delay + jitter;\n}\n\n","/**\n * Offline Queue for Mutations\n * Queues mutations when offline and replays them when connection is restored\n */\n\nimport uuid from 'react-native-uuid';\nimport { Route } from '../../types';\n\n// Import MMKV storage (has set, getString methods)\nlet storage: any;\ntry {\n  storage = require('../../utils/storage').default;\n} catch (e) {\n  // Fallback if storage not available\n  storage = {\n    set: () => {},\n    getString: () => undefined,\n  };\n}\n\nexport interface QueuedMutation {\n  id: string;\n  route: Route;\n  variables: Record<string, any>;\n  timestamp: number;\n  retries: number;\n  maxRetries: number;\n}\n\nconst STORAGE_KEY = 'offline_mutation_queue';\nconst DEFAULT_MAX_RETRIES = 3;\n\n/**\n * Offline Mutation Queue\n * Persists mutations to local storage and processes them when online\n */\nexport class OfflineQueue {\n  private queue: QueuedMutation[] = [];\n  private isProcessing = false;\n\n  constructor() {\n    this.loadFromStorage();\n  }\n\n  /**\n   * Adds a mutation to the queue\n   */\n  async enqueue(\n    mutation: Omit<QueuedMutation, 'id' | 'timestamp' | 'retries' | 'maxRetries'>\n  ): Promise<string> {\n    const item: QueuedMutation = {\n      ...mutation,\n      id: uuid.v4() as string,\n      timestamp: Date.now(),\n      retries: 0,\n      maxRetries: DEFAULT_MAX_RETRIES,\n    };\n\n    this.queue.push(item);\n    await this.persist();\n\n    return item.id;\n  }\n\n  /**\n   * Processes the queue\n   */\n  async processQueue(\n    onProcess: (item: QueuedMutation) => Promise<void>\n  ): Promise<void> {\n    if (this.isProcessing || this.queue.length === 0) {\n      return;\n    }\n\n    this.isProcessing = true;\n\n    while (this.queue.length > 0) {\n      const item = this.queue[0];\n\n      try {\n        await onProcess(item);\n        // Success - remove from queue\n        this.queue.shift();\n        await this.persist();\n      } catch (error) {\n        // Failure - increment retries\n        item.retries++;\n\n        if (item.retries >= item.maxRetries) {\n          // Give up on this item\n          console.warn(`[OfflineQueue] Giving up on mutation ${item.id} after ${item.retries} retries`);\n          this.queue.shift();\n          await this.persist();\n        } else {\n          // Stop processing, will retry later\n          break;\n        }\n      }\n    }\n\n    this.isProcessing = false;\n  }\n\n  /**\n   * Gets the current queue\n   */\n  getQueue(): ReadonlyArray<QueuedMutation> {\n    return [...this.queue];\n  }\n\n  /**\n   * Gets the queue size\n   */\n  size(): number {\n    return this.queue.length;\n  }\n\n  /**\n   * Clears the entire queue\n   */\n  async clear(): Promise<void> {\n    this.queue = [];\n    await this.persist();\n  }\n\n  /**\n   * Removes a specific mutation from the queue\n   */\n  async remove(id: string): Promise<boolean> {\n    const index = this.queue.findIndex((item) => item.id === id);\n    if (index > -1) {\n      this.queue.splice(index, 1);\n      await this.persist();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Persists queue to storage\n   */\n  private async persist(): Promise<void> {\n    try {\n      storage.set(STORAGE_KEY, JSON.stringify(this.queue));\n    } catch (error) {\n      console.error('[OfflineQueue] Failed to persist queue:', error);\n    }\n  }\n\n  /**\n   * Loads queue from storage\n   */\n  private loadFromStorage(): void {\n    try {\n      const stored = storage.getString(STORAGE_KEY);\n      if (stored) {\n        this.queue = JSON.parse(stored);\n      }\n    } catch (error) {\n      console.error('[OfflineQueue] Failed to load queue:', error);\n      this.queue = [];\n    }\n  }\n}\n\n// Singleton instance\nlet queueInstance: OfflineQueue | null = null;\n\n/**\n * Gets the singleton queue instance\n */\nexport function getOfflineQueue(): OfflineQueue {\n  if (!queueInstance) {\n    queueInstance = new OfflineQueue();\n  }\n  return queueInstance;\n}\n\n","/**\n * Refetch Manager\n * Handles background refetching on focus, reconnect, and intervals\n */\n\nimport { useEffect, useRef } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\nimport { useSocket } from '../../store/contexts/socket-context';\n\n/**\n * Refetches when app comes to foreground\n * @param enabled - Whether this behavior is enabled\n * @param refetch - Function to call for refetching\n */\nexport function useRefetchOnFocus(\n  enabled: boolean,\n  refetch: () => void\n): void {\n  const appState = useRef(AppState.currentState);\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    const subscription = AppState.addEventListener('change', (nextAppState: AppStateStatus) => {\n      // App has come to the foreground\n      if (\n        appState.current.match(/inactive|background/) &&\n        nextAppState === 'active'\n      ) {\n        refetch();\n      }\n\n      appState.current = nextAppState;\n    });\n\n    return () => {\n      subscription.remove();\n    };\n  }, [enabled, refetch]);\n}\n\n/**\n * Refetches when network reconnects\n * @param enabled - Whether this behavior is enabled\n * @param refetch - Function to call for refetching\n */\nexport function useRefetchOnReconnect(\n  enabled: boolean,\n  refetch: () => void\n): void {\n  const { connected } = useSocket();\n  const prevConnected = useRef(connected);\n\n  useEffect(() => {\n    if (enabled && connected && !prevConnected.current) {\n      // Just reconnected\n      refetch();\n    }\n    prevConnected.current = connected;\n  }, [connected, enabled, refetch]);\n}\n\n/**\n * Refetches at a regular interval\n * @param enabled - Whether polling is enabled\n * @param refetch - Function to call for refetching\n * @param interval - Interval in milliseconds\n */\nexport function useRefetchInterval(\n  enabled: boolean,\n  refetch: () => void,\n  interval: number\n): void {\n  useEffect(() => {\n    if (!enabled || interval <= 0) return;\n\n    const timer = setInterval(() => {\n      refetch();\n    }, interval);\n\n    return () => {\n      clearInterval(timer);\n    };\n  }, [enabled, refetch, interval]);\n}\n\n","import AlphaStorage from \"../utils/storage\";\nimport { combineReducers, configureStore } from \"@reduxjs/toolkit\";\nimport AppReducer from \"./reducers/app-reducer\";\nimport CacheReducer from \"./reducers/cache-reducer\";\nimport ThreadReducer from \"./reducers/thread-reducer\";\n\nconst saveToLocalStorage = (state:any) => {\n\ttry {\n\t\tAlphaStorage.setItem('_state', state);\n\t} catch (e) {\n\t\tconsole.log(e);\n\t}\n};\n\nconst loadFromLocalStorage = () => {\n\ttry {\n\t\tconst serializedState = AlphaStorage.getItem('_state');\n\t\tif (serializedState === null) return undefined;\n\t\treturn serializedState;\n\t} catch (e) {\n\t\treturn undefined;\n\t}\n};\n\nconst preloadedState = loadFromLocalStorage();\n\nconst rootReducer = combineReducers({\n\tapp: AppReducer,\n\tcache: CacheReducer,\n\ttread: ThreadReducer,\n});\n\nexport const store = configureStore({\n\treducer: rootReducer,\n\tpreloadedState: preloadedState as Partial<ReturnType<typeof rootReducer>>,\n\tmiddleware: (getDefaultMiddleware) => getDefaultMiddleware({\n\t\timmutableCheck: false,\n\t\tserializableCheck: false,\n\t}),\n});\n\nstore.subscribe(() => {\n\tsaveToLocalStorage(store.getState());\n\t// console.log(\"update\", store.getState());\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\n","function money(num:number, decimal:number) {\n    if (num || num === 0){\n        return num.toFixed(decimal).replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1,')\n    }\n    return \"-.--\"\n}\nexport default money;\n","import CryptoJS from \"react-native-crypto-js\";\nconst key = CryptoJS.enc.Utf8.parse(\"2vn!H3KXgX-TxvkD\");\nconst iv  = CryptoJS.enc.Utf8.parse(\"%x%97Uw@*A2xWaUJ\");\n\nexport const encrypt=(payload:string)=>{\n    return CryptoJS.AES.encrypt(payload, key, {iv: iv, mode: CryptoJS.mode.CBC,padding: CryptoJS.pad.Pkcs7}).toString();\n}\n\nexport const decrypt=(response:string)=>{\n    const decrypted_response = CryptoJS.AES.decrypt({ciphertext:CryptoJS.enc.Base64.parse(response)},key,{iv: iv});\n    return decrypted_response.toString(CryptoJS.enc.Utf8);\n}\n"],"mappings":"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","names":["key","useEffect","useMemo","useRef","useCallback","key","config","key","createSlice","initialState","actions","createContext","useContext","useEffect","useState","NetInfo","jsx","defaultValue","createContext","useContext","useState","useEffect","NetInfo","actions","createSlice","initialState","actions","key","key","isAbortError","isAbortError","key","key","useRef","useEffect","useCallback","actions","isAbortError","useMemo","key","actions","isAbortError","useState","useCallback","useRef","useEffect","useState","useRef","useEffect","useCallback","isAbortError","useState","useCallback","useRef","useEffect","Keyboard","useState","useRef","useEffect","useCallback","Keyboard","isAbortError","isAbortError","shouldRetry","formatFormData","key","formatUrlEncoded","key","uuid","storage","useEffect","useRef","AppState","useRef","AppState","useEffect"]}
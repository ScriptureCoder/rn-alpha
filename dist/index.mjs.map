{"version":3,"sources":["../src/utils/storage.ts","../src/index.ts","../src/hooks/use-query.tsx","../src/utils/service.ts","../src/config.ts","../src/store/contexts/app-context.tsx","../src/hooks/use-selector.tsx","../src/hooks/use-dispatch.tsx","../src/store/reducers/app-reducer.tsx","../src/store/reducers/cache-reducer.tsx","../src/store/reducers/thread-reducer.tsx","../src/hooks/use-cache.tsx","../src/paths.ts","../src/hooks/utils/route-parser.ts","../src/hooks/utils/error-handler.ts","../src/store/contexts/socket-context.tsx","../src/hooks/constants.ts","../src/hooks/utils/request-queue.ts","../src/hooks/utils/cache-helpers.ts","../src/hooks/utils/response-helpers.ts","../src/store/contexts/config-context.tsx","../src/hooks/utils/debug-logger.ts","../src/utils/crypto.ts","../src/hooks/utils/encryption-helpers.ts","../src/hooks/use-query-async.tsx","../src/hooks/use-mutation.tsx","../src/hooks/use-mutation-async.tsx","../src/utils/http-helpers.ts","../src/hooks/utils/retry-manager.ts","../src/hooks/utils/offline-queue.ts","../src/hooks/utils/refetch-manager.ts","../src/store/contexts/alpha-provider.tsx","../src/store/create-store.ts","../src/store/type-helpers.ts","../src/utils/money.ts","../src/utils/getMime.ts","../src/utils/capitalize.ts","../src/utils/toast.ts","../src/utils/readFile.ts"],"sourcesContent":["import { MMKV } from 'react-native-mmkv'\n\nconst storage = new MMKV()\n\nclass Storage {\n\n    setItem=(key:string, value:any)=> {\n        try {\n            return storage.set(key, JSON.stringify(value))\n        } catch (e) {\n        }\n    };\n\n    getItem=(key:string)=> {\n        try {\n            const value = storage.getString(key);\n            if (value) {\n                return JSON.parse(value)\n            }\n            return undefined\n        } catch(e) {\n        }\n    };\n\n    removeItem=(key:string)=> {\n        try {\n            storage.delete(key)\n        } catch(e) {\n            // remove error\n        }\n    };\n\n    clear=async ()=> (\n        storage.clearAll()\n    )\n\n}\n\nexport default new Storage()\n","import dayjs from 'dayjs';\nimport relativeTime from 'dayjs/plugin/relativeTime';\nimport utc from 'dayjs/plugin/utc';\nimport timezone from 'dayjs/plugin/timezone';\n\ndayjs.extend(relativeTime);\ndayjs.extend(utc);\ndayjs.extend(timezone);\n\n// Hooks exports\nexport { default as useQuery } from './hooks/use-query';\nexport { default as useQueryAsync } from './hooks/use-query-async';\nexport { default as useMutation } from './hooks/use-mutation';\nexport { default as useMutationAsync } from './hooks/use-mutation-async';\nexport { default as useDispatch } from './hooks/use-dispatch';\nexport { default as useSelector } from './hooks/use-selector';\nexport { default as useCache } from './hooks/use-cache';\nexport { useApp } from './store/contexts/app-context';\nexport { dayjs };\n\n// Hook types\nexport type {\n  QueryOptions,\n  QueryResult,\n  MutationOptions,\n  MutationResponse,\n  MutationResult,\n  CacheOperations,\n  TimingInfo,\n  EncryptionOptions,\n} from './hooks/types';\nexport type { NetworkPolicy, ConcatStrategy } from './hooks/constants';\nexport type {\n  ParsedRoute,\n  ErrorResponse,\n  SuccessResponse,\n  ApiResponse,\n} from './hooks/utils';\n\n// Cache types\nexport type { CacheEntry, CacheState, CacheMetadata } from './store/reducers/cache-reducer';\nexport { setMaxCacheSize, getCacheMetadata } from './store/reducers/cache-reducer';\n\n// HTTP service types and utilities\nexport type { HttpOptions, ContentType, HttpResponse } from './utils/service';\nexport { isAbortError as isHttpAbortError } from './utils/service';\n\n// HTTP helper utilities\nexport {\n  createAbortController,\n  isAbortError,\n  isCancelError,\n  shouldRetry,\n  formatFormData,\n  formatUrlEncoded,\n  safeAbort,\n  createTimeoutController,\n  combineAbortSignals,\n} from './utils/http-helpers';\n\n// Error handler utilities\nexport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  createErrorResponse,\n  createSuccessResponse,\n} from './hooks/utils/error-handler';\n\n// Response helpers\nexport { extractResponseData } from './hooks/utils/response-helpers';\n\n// NEW: Request deduplication\nexport {\n  getOrCreateRequest,\n  cancelRequest,\n  isRequestInFlight,\n  getInFlightCount,\n  clearAllRequests,\n} from './hooks/utils/request-queue';\n\n// NEW: Cache helpers\nexport {\n  isCacheExpired,\n  isCacheStale,\n  isCacheFresh,\n  getCacheData,\n  createCacheEntry,\n  getCacheAge,\n  canUseCache,\n} from './hooks/utils/cache-helpers';\n\n// NEW: Debug logger\nexport {\n  QueryDebugger,\n  createDebugger,\n  enableGlobalDebug,\n  disableGlobalDebug,\n  isGlobalDebugEnabled,\n} from './hooks/utils/debug-logger';\nexport type { QueryDebugInfo } from './hooks/utils/debug-logger';\n\n// NEW: Retry manager\nexport {\n  retryWithBackoff,\n  retryWithJitter,\n} from './hooks/utils/retry-manager';\nexport type { RetryOptions } from './hooks/utils/retry-manager';\n\n// NEW: Offline queue\nexport {\n  OfflineQueue,\n  getOfflineQueue,\n} from './hooks/utils/offline-queue';\nexport type { QueuedMutation } from './hooks/utils/offline-queue';\n\n// NEW: Refetch hooks\nexport {\n  useRefetchOnFocus,\n  useRefetchOnReconnect,\n  useRefetchInterval,\n} from './hooks/utils/refetch-manager';\n\n// Configuration Provider (NEW - Recommended)\nexport { AlphaProvider } from './store/contexts/alpha-provider';\nexport type { AlphaConfig } from './config';\nexport { DEFAULT_CONFIG } from './config';\nexport { useAlphaConfig } from './store/contexts/config-context';\n\n// Store exports\nexport { default as AppProvider } from './store/contexts/app-context';\nexport { AppContextValue } from './store/contexts/app-context';\nexport { store, createAlphaStore, defaultStore } from './store';\nexport type { \n  AppDispatch, \n  RootState, \n  CustomReducers, \n  StoreOptions,\n  CoreAppState,\n  LegacyAppState,\n} from './store';\nexport { appActions } from './store';\n\n// TypeScript helpers for custom stores\nexport {\n  createTypedSelector,\n  createTypedDispatch,\n  useAppSelector,\n  useAppDispatch,\n  createSelector,\n  createSlice,\n} from './store/type-helpers';\nexport type {\n  InferActions,\n  ExtendedRootState,\n  ExtendedAppContext,\n  StateFromReducer,\n} from './store/type-helpers';\n\nexport { config as alphaConfig, naira } from './config';\nexport { default as PATHS } from './paths';\nexport * from './types';\n\n// HTTP Config (Advanced use)\nexport { setHttpConfig, getHttpConfig } from './utils/service';\n\nexport { default as formatMoney } from './utils/money';\nexport { \n  encrypt, \n  decrypt, \n  setEncryptionConfig, \n  getEncryptionConfig,\n  isValidEncryptionConfig,\n  generateEncryptionConfig,\n} from './utils/crypto';\nexport type { EncryptionConfig } from './utils/crypto';\nexport { default as storage } from './utils/storage';\n\n// Additional utility functions\nexport { default as getMime } from './utils/getMime';\nexport { default as capitalize } from './utils/capitalize';\nexport { default as Toast } from './utils/toast';\nexport { default as readFile } from './utils/readFile';\n\n// HTTP service (advanced use - direct access to http function)\nexport { default as http } from './utils/service';\nexport type { Method } from './utils/service';\n\n// NEW: Constants\nexport {\n  DEFAULT_CACHE_TTL,\n  DEFAULT_STALE_TIME,\n  MAX_CACHE_SIZE,\n  NETWORK_TIMEOUT,\n  ERROR_MESSAGES,\n  STATUS_CODES,\n} from './hooks/constants';\n","import { useEffect, useMemo, useRef, useCallback } from \"react\";\nimport http, { Method } from \"../utils/service\";\nimport { useApp } from \"store/contexts/app-context\";\nimport useDispatch from \"./use-dispatch\";\nimport useSelector from \"./use-selector\";\nimport { actions } from \"store/reducers/cache-reducer\";\nimport * as network from \"../store/reducers/thread-reducer\";\nimport useCache from \"./use-cache\";\nimport { useSocket } from \"store/contexts/socket-context\";\nimport { Route } from \"types\";\nimport { QueryOptions, QueryResult } from \"./types\";\nimport { NetworkPolicy, NETWORK_TIMEOUT } from \"./constants\";\nimport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  isAbortError,\n} from \"hooks/utils\";\nimport { getOrCreateRequest, cancelRequest } from \"./utils/request-queue\";\nimport {\n  isCacheExpired,\n  isCacheStale,\n  getCacheData,\n} from \"./utils/cache-helpers\";\nimport { extractResponseData } from \"./utils/response-helpers\";\nimport { useAlphaConfig } from \"store/contexts/config-context\";\nimport {\n  resolveEncryptionOptions,\n  applyRequestEncryption,\n  applyResponseDecryption,\n} from \"./utils/encryption-helpers\";\n\n/**\n * Custom hook for data fetching with caching support\n * @param route - The API route key\n * @param args - Query options including variables, network policy, callbacks\n * @returns QueryResult with data, loading state, and cache manipulation functions\n */\nconst useQuery = (route: Route, args?: QueryOptions): QueryResult => {\n  const { variables = {}, networkPolicy, init, onCompleted, onError, encrypted, dataPath, idRef } = args || {};\n  const app = useApp();\n  const { auth } = app;\n  const cache = useCache();\n  const { key, path, method } = cache.getContext(route, variables);\n  const policy: NetworkPolicy = networkPolicy || \"cache-first\";\n  const [config] = useAlphaConfig();\n\n  // Resolve encryption options (hook option > global config)\n  const encryptionOptions = resolveEncryptionOptions(encrypted, config.defaultEncryption);\n\n  // Resolve dataPath (hook option > global config)\n  const resolvedDataPath = dataPath !== undefined ? dataPath : config.dataPath;\n\n  const data = useSelector((state) => state.cache[key]);\n  const thread = useSelector((state) => state.thread[key]);\n\n  const dispatch = useDispatch();\n  const { connected } = useSocket();\n\n  // Use ref to store timeout ID for cleanup\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Use ref to store abort controller for request cancellation\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Handle data completion and retry on connection\n  useEffect(() => {\n    if (data?.data && onCompleted) {\n      onCompleted(data?.data);\n    }\n    if (connected && thread?.error && (!data || (Array.isArray(data) && data.length < 1))) {\n      refetch({});\n    }\n  }, [data, connected, thread?.error]);\n\n  // Initial fetch on mount\n  useEffect(() => {\n    fetchData(variables);\n\n    // Cleanup on unmount\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  // Handle initial data\n  useEffect(() => {\n    if (init && init.timestamp > (data?.timestamp || 0)) {\n      dispatch(actions.init({ key, value: init }));\n    }\n  }, [init?.timestamp, key, dispatch, data?.timestamp]);\n\n  /**\n   * Sets the loading/error/status state for this query\n   */\n  const setThread = useCallback(\n    (loading: boolean, error?: string, status?: number) => {\n      dispatch(\n        network.actions.set({\n          key,\n          value: {\n            loading,\n            error,\n            status,\n          },\n        })\n      );\n    },\n    [dispatch, key]\n  );\n\n  /**\n   * Main fetch logic based on network policy\n   */\n  const fetchData = useCallback(\n    (fetchVariables: Record<string, any>) => {\n      switch (policy) {\n        case \"cache-only\":\n          return;\n        case \"network-only\":\n          fetchHandler(fetchVariables, true).catch(() => {});\n          return;\n        case \"cache-first\":\n          if (!data) {\n            fetchHandler(fetchVariables).catch(() => {});\n          }\n          return;\n        case \"network-and-cache\":\n          fetchHandler(fetchVariables).catch(() => {});\n          timeoutRef.current = setTimeout(() => {\n            const currentThread = thread;\n            if (currentThread?.loading) {\n              refetch({});\n            }\n          }, NETWORK_TIMEOUT);\n          return;\n        case \"stale-while-revalidate\":\n          // Show stale data immediately if available and not expired\n          if (data && !isCacheExpired(data)) {\n            // If data is stale, refetch in background\n            if (isCacheStale(data)) {\n              fetchHandler(fetchVariables).catch(() => {});\n            }\n          } else {\n            // No cache or expired, fetch normally\n            fetchHandler(fetchVariables).catch(() => {});\n          }\n          return;\n      }\n    },\n    [policy, data, thread]\n  );\n\n  /**\n   * Handles the actual HTTP request\n   */\n  const fetchHandler = useCallback(\n    async (fetchVariables: Record<string, any>, isRefetch: boolean = false) => {\n      try {\n        // Only fetch if not currently loading or if it's a refetch or there's an error\n        if (!thread?.loading || thread?.error || isRefetch) {\n          // Abort any existing request\n          if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n          }\n\n          // Create new abort controller for this request\n          abortControllerRef.current = new AbortController();\n\n          setThread(true);\n\n          // Apply request encryption if enabled\n          const requestData = encryptionOptions\n            ? applyRequestEncryption(fetchVariables, encryptionOptions)\n            : fetchVariables;\n\n          // Use request deduplication to prevent duplicate requests\n          const res: any = await getOrCreateRequest(key, () =>\n            http(\n              path,\n              (method as Method) || \"GET\",\n              requestData,\n              {\n                returnStatus: true,\n                auth: auth.accessToken,\n                signal: abortControllerRef.current.signal,\n              }\n            )\n          );\n\n          const error = !isSuccessStatus(res.status)\n            ? extractErrorMessage(res)\n            : undefined;\n\n          setThread(false, error, res.status);\n\n          if (isSuccessStatus(res.status)) {\n            let responseData = res.data\n            // Apply response decryption if enabled\n            if (encryptionOptions && responseData) {\n              responseData = applyResponseDecryption(responseData, encryptionOptions);\n            }\n\n            responseData = extractResponseData(responseData, resolvedDataPath);\n\n            if (responseData) {\n              if (onCompleted) {\n                onCompleted(responseData);\n              }\n              cache.setCache(key, responseData);\n            }\n          } else if (isAuthError(res.status)) {\n            // Auth error - clear authentication\n            app.clearAuth();\n          } else if (error && onError) {\n            onError(error, res.status);\n          }\n        }\n      } catch (e: any) {\n        // Ignore abort errors - they're intentional cancellations\n        if (isAbortError(e)) {\n          return;\n        }\n\n        const error = e.message || \"Oops! an error occurred\";\n        setThread(false, error, 500);\n        if (onError) {\n          onError(error, 500);\n        }\n      }\n    },\n    [thread, setThread, path, method, auth.accessToken, onCompleted, onError, cache, key, app, encryptionOptions, resolvedDataPath]\n  );\n\n  /**\n   * Refetches data with optional new variables\n   */\n  const refetch = useCallback(\n    (refetchVariables?: Record<string, any>) => {\n      fetchHandler({ ...variables, ...(refetchVariables || {}) }, true).catch(() => {});\n    },\n    [fetchHandler, variables]\n  );\n\n  /**\n   * Fetches more data and concatenates with existing data\n   */\n  const fetchMore = useCallback(\n    async (\n      fetchMoreVariables?: Record<string, any>,\n      concat?: \"start\" | \"end\" | \"pagination\",\n      paginationKey?: string\n    ) => {\n      try {\n        // Create abort controller for fetchMore\n        const fetchMoreController = new AbortController();\n\n        const res: any = await http(\n          path,\n          (method as Method) || \"GET\",\n          { ...variables, ...(fetchMoreVariables || {}) },\n          {\n            returnStatus: true,\n            auth: auth?.accessToken,\n            signal: fetchMoreController.signal,\n          }\n        );\n\n        const error = !isSuccessStatus(res.status)\n          ? extractErrorMessage(res)\n          : undefined;\n\n        if (isSuccessStatus(res.status)) {\n          if (concat === \"start\") {\n            dispatch(actions.prepend({ key, value: res.data.data }));\n          } else if (concat === \"end\") {\n            dispatch(actions.append({ key, value: res.data.data }));\n          } else if (concat === \"pagination\") {\n            dispatch(\n              actions.paginate({\n                key,\n                data: res.data.data,\n                paginationKey: paginationKey || \"data\",\n              })\n            );\n          }\n          return { data: res.data.data };\n        } else if (isAuthError(res.status)) {\n          // Auth error - clear authentication\n          app.clearAuth();\n          return { error };\n        }\n        return { error };\n      } catch (e: any) {\n        // Handle abort errors\n        if (isAbortError(e)) {\n          return { error: \"Request cancelled\" };\n        }\n\n        const error = e.message || \"Oops! an error occurred\";\n        return { error };\n      }\n    },\n    [path, method, variables, auth?.accessToken, dispatch, key, app]\n  );\n\n  /**\n   * Aborts the current request\n   */\n  const abort = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n    // Also remove from deduplication queue\n    cancelRequest(key);\n  }, [key]);\n\n  /**\n   * Optimistic update with automatic rollback\n   */\n  const optimisticUpdate = useCallback(\n    (updater: (current: any) => any, rollback?: () => void) => {\n      const currentData = data;\n      const newData = updater(currentData);\n\n      // Update immediately\n      cache.update(key, newData);\n\n      // Return rollback function\n      return () => {\n        if (rollback) {\n          rollback();\n        } else {\n          cache.update(key, currentData);\n        }\n      };\n    },\n    [data, key, cache]\n  );\n\n  /**\n   * Cache manipulation functions bound to current key\n   */\n  const extendCache = useMemo(\n    () => ({\n      update: (newData: any) => {\n        cache.update(key, newData);\n      },\n      updateValue: (arg: string, value: any) => {\n        cache.updateValue(key, arg, value);\n      },\n      updateValues: (values: Record<string, any>) => {\n        cache.updateValues(key, values);\n      },\n      updateItem: (id: string, value: any) => {\n        cache.updateItem(key, id, value, idRef);\n      },\n      deleteItem: (id: string) => {\n        cache.deleteItem(key, id, idRef);\n      },\n      prepend: (newData: any) => {\n        cache.prepend(key, newData);\n      },\n      append: (newData: any) => {\n        cache.append(key, newData);\n      },\n    }),\n    [key, cache, idRef]\n  );\n\n  return {\n    data: data?.data || init,\n    loading: thread?.loading || false,\n    error: thread?.error,\n    status: thread?.status,\n    refetch,\n    key,\n    fetchMore,\n    abort,\n    optimisticUpdate,\n    ...extendCache,\n  };\n};\n\nexport default useQuery;\n","import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport config from 'config';\nimport { AlphaConfig, DEFAULT_CONFIG } from '../config';\n\nexport type Method = 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH';\nexport type ContentType = 'json' | 'urlencoded' | 'multipart';\n\n// Current configuration\nlet currentConfig: AlphaConfig = DEFAULT_CONFIG;\n\nexport interface HttpOptions {\n  auth?: string;\n  contentType?: ContentType;\n  signal?: AbortSignal;\n  timeout?: number;\n  returnStatus?: boolean;\n  returnText?: boolean;\n}\n\nexport interface HttpResponse<T = any> {\n  data: {\n    data?: T;\n    error?: string;\n    ResponseDescription?: string;\n  };\n  status: number;\n}\n\n/**\n * Internal: Set current config (called by ConfigProvider)\n * @param config - Alpha configuration\n */\nexport function setHttpConfig(newConfig: AlphaConfig): void {\n  currentConfig = newConfig;\n  // Recreate axios instance with new config\n  axiosInstance = createAxiosInstance();\n}\n\n/**\n * Get current HTTP config\n * @returns Current Alpha configuration\n */\nexport function getHttpConfig(): AlphaConfig {\n  return currentConfig;\n}\n\n/**\n * Creates and configures an Axios instance with base configuration\n */\nconst createAxiosInstance = (): AxiosInstance => {\n  const instance = axios.create({\n    baseURL: currentConfig.baseUrl || config.baseUrl,\n    timeout: currentConfig.timeout || 30000,\n    headers: {\n      Accept: 'application/json',\n      ...(currentConfig.headers || {}),\n    },\n  });\n\n  // Response interceptor for standardized error handling\n  instance.interceptors.response.use(\n    (response) => response,\n    (error) => {\n      // Don't transform abort errors\n      if (axios.isCancel(error) || error.name === 'AbortError') {\n        return Promise.reject(error);\n      }\n\n      // Network error\n      if (!error.response) {\n        return Promise.resolve({\n          data: {\n            error: error.message || 'Network error occurred',\n          },\n          status: 500,\n        });\n      }\n\n      // HTTP error response\n      return Promise.resolve(error.response);\n    }\n  );\n\n  return instance;\n};\n\n// Singleton axios instance\nlet axiosInstance = createAxiosInstance();\n\n/**\n * Converts object to URL-encoded string\n */\nconst formatUrlEncoded = (data: Record<string, any>): string => {\n  const formBody: string[] = [];\n  for (const property in data) {\n    const encodedKey = encodeURIComponent(property);\n    const encodedValue = encodeURIComponent(data[property]);\n    formBody.push(`${encodedKey}=${encodedValue}`);\n  }\n  return formBody.join('&');\n};\n\n/**\n * Converts object to FormData for multipart requests\n */\nconst formatFormData = (data: Record<string, any>): FormData => {\n  const formData = new FormData();\n  for (const key in data) {\n    formData.append(key, data[key]);\n  }\n  return formData;\n};\n\n/**\n * Get appropriate Content-Type header based on type\n */\nconst getContentTypeHeader = (contentType: ContentType): string => {\n  switch (contentType) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded';\n    case 'multipart':\n      return 'multipart/form-data';\n    case 'json':\n    default:\n      return 'application/text';\n  }\n};\n\n/**\n * Format request data based on content type\n */\nconst formatRequestData = (\n  data: any,\n  contentType: ContentType,\n  method: Method\n): any => {\n  // GET requests don't have body\n  if (method === 'GET') {\n    return undefined;\n  }\n\n  if (!data) {\n    return undefined;\n  }\n\n  switch (contentType) {\n    case 'urlencoded':\n      return formatUrlEncoded(data);\n    case 'multipart':\n      return formatFormData(data);\n    case 'json':\n    default:\n      return data;\n  }\n};\n\n/**\n * Modern HTTP client with axios\n * Supports multiple Content-Types, request cancellation, and better error handling\n *\n * @param path - API endpoint path\n * @param method - HTTP method (GET, POST, PUT, DELETE, PATCH)\n * @param data - Request data (body for POST/PUT/PATCH, query params for GET)\n * @param options - Additional options (auth, contentType, signal, timeout, etc.)\n * @returns Promise with standardized response format\n *\n * @example\n * // JSON request (default)\n * const response = await http('/users', 'POST', { name: 'John' });\n *\n * @example\n * // URL-encoded request\n * const response = await http('/login', 'POST', { email, password }, { contentType: 'urlencoded' });\n *\n * @example\n * // With abort signal\n * const controller = new AbortController();\n * const response = await http('/data', 'GET', {}, { signal: controller.signal });\n * // Later: controller.abort();\n */\nasync function http<T = any>(\n  path: string,\n  method?: Method,\n  data?: any,\n  options?: HttpOptions\n): Promise<HttpResponse<T>>;\n\n// Legacy signature for backward compatibility\nasync function http<T = any>(\n  path: string,\n  method: Method,\n  data: any,\n  returnStatus: boolean,\n  auth?: string,\n  returnText?: boolean\n): Promise<HttpResponse<T>>;\n\n// Implementation\nasync function http<T = any>(\n  path: string,\n  method: Method = 'GET',\n  data?: any,\n  optionsOrStatus?: HttpOptions | boolean,\n  legacyAuth?: string,\n  legacyReturnText?: boolean\n): Promise<HttpResponse<T>> {\n  // Handle legacy signature\n  let options: HttpOptions;\n  if (typeof optionsOrStatus === 'boolean') {\n    options = {\n      returnStatus: optionsOrStatus,\n      auth: legacyAuth,\n      returnText: legacyReturnText,\n      contentType: 'urlencoded', // Legacy default\n    };\n  } else {\n    options = optionsOrStatus || {};\n  }\n\n  const {\n    auth,\n    contentType = 'json',\n    signal,\n    timeout,\n    returnStatus = true,\n    returnText = false,\n  } = options;\n\n  try {\n    // Prepare headers\n    const headers: Record<string, string> = {\n      'Content-Type': getContentTypeHeader(contentType),\n      // 'Content-Type': \"application/x-www-form-urlencoded\",\n    };\n\n    if (auth) {\n      headers['Authorization'] = auth;\n    }\n    console.log(headers, method, path);\n    // Prepare request config\n    const config: AxiosRequestConfig = {\n      method,\n      url: path,\n      headers,\n      signal,\n      timeout: timeout || 30000,\n    };\n\n    console.log({data});\n    // Handle data based on method and content type\n    if (method === 'GET' && data) {\n      // For GET, data becomes query params\n      config.params = data;\n    } else {\n      // For other methods, format body based on content type\n      config.data = formatRequestData(data, contentType, method);\n    }\n    console.log(config);\n    // Make the request\n    const response: AxiosResponse = await axiosInstance.request(config);\n\n    console.log(response);\n    // Format response based on options\n    if (returnStatus) {\n      return {\n        data: returnText\n          ? response.data\n          : typeof response.data === 'string'\n          ? response.data\n          : response.data,\n        status: response.status,\n      };\n    }\n\n    return response.data;\n  } catch (error: any) {\n    // Re-throw abort/cancel errors so they can be handled by the caller\n    if (axios.isCancel(error) || error.name === 'AbortError') {\n      throw error;\n    }\n\n    // Return error response in standard format\n    return {\n      data: error.response?.data || { error: error.message || 'An error occurred' },\n      status: error.response?.status || 500,\n    };\n  }\n}\n\nexport default http;\n\n/**\n * Check if an error is an abort/cancel error\n */\nexport const isAbortError = (error: any): boolean => {\n  return (\n    axios.isCancel(error) ||\n    error.name === 'AbortError' ||\n    error.name === 'CanceledError'\n  );\n};\n","export interface AlphaConfig {\n  // API Configuration (required)\n  baseUrl: string;\n  \n  // Optional API settings\n  timeout?: number; // Default: 30000ms\n  headers?: Record<string, string>;\n  \n  // Custom Routes\n  paths?: Record<string, string>; // e.g. { login: 'POST:/auth/login' }\n  \n  // Cache Configuration\n  cache?: {\n    ttl?: number; // Default cache TTL\n    staleTime?: number; // Default stale time\n    maxSize?: number; // LRU max size\n  };\n  \n  // Default Network Policy\n  defaultNetworkPolicy?: 'cache-first' | 'network-only' | 'cache-only' | 'network-and-cache' | 'stale-while-revalidate';\n  \n  // Retry Configuration\n  retry?: {\n    enabled?: boolean;\n    count?: number;\n    delay?: number | 'exponential';\n  };\n  \n  // Encryption Configuration\n  encryption?: {\n    key: string; // Must be 16 characters for AES-128\n    iv: string;  // Must be 16 characters\n  };\n  \n  // Default encryption behavior for all requests/responses\n  defaultEncryption?: boolean | {\n    enabled?: boolean;\n    request?: 'full' | string[];\n    response?: 'full' | string[];\n  };\n  \n  // Response data path\n  dataPath?: string; // Default: \"data\" (means res.data.data), empty string for res.data\n  \n  // Debug mode\n  debug?: boolean;\n}\n\n// Default configuration\nexport const DEFAULT_CONFIG: AlphaConfig = {\n  baseUrl: '',\n  timeout: 30000,\n  cache: {\n    ttl: 5 * 60 * 1000,\n    staleTime: 0,\n    maxSize: 100,\n  },\n  defaultNetworkPolicy: 'cache-first',\n  retry: {\n    enabled: true,\n    count: 3,\n    delay: 'exponential',\n  },\n  encryption: undefined, // No default - must be provided for security\n  defaultEncryption: false, // No encryption by default\n  dataPath: 'data', // Default to res.data.data for backward compatibility\n  debug: false,\n};\n\nexport const naira = 'â‚¦';\n\n// Legacy export for backward compatibility\nexport const config = {\n  naira,\n  baseUrl: '',\n};\n\nexport default config;\n","import React, {\n    createContext,\n    useContext,\n    useEffect,\n    useMemo,\n    useState,\n} from 'react';\nimport NetInfo from '@react-native-community/netinfo';\nimport useSelector from '../../hooks/use-selector';\nimport useDispatch from '../../hooks/use-dispatch';\nimport { actions, CoreAppState } from '../reducers/app-reducer';\n\n/**\n * Core app context type\n * Apps can extend this with their own methods by creating a custom context\n */\nexport interface AppContextValue {\n    // Core state\n    auth: CoreAppState['auth'];\n    colorMode: CoreAppState['colorMode'];\n    user: any;\n    connected: boolean;\n\n    // Core actions\n    setAuth: (payload: Partial<CoreAppState['auth']>) => void;\n    setUser: (payload: any) => void;\n    clearAuth: () => void;\n}\n\nconst AppContext = createContext<AppContextValue | undefined>(undefined);\n\n/**\n * Hook to access app context\n * Can be typed for custom extensions: useApp<MyAppContextType>()\n */\nexport const useApp = <T = AppContextValue>(): T => {\n    const context = useContext(AppContext);\n    if (!context) {\n        throw new Error('useApp must be used within AppProvider');\n    }\n    return context as unknown as T;\n};\n\n/**\n * Minimal app provider with core functionality only\n * Apps can wrap this or create their own context for additional state\n *\n * @example\n * // Basic usage\n * <AppProvider>\n *   <App />\n * </AppProvider>\n *\n * @example\n * // Extended usage in your app\n * function MyAppProvider({ children }) {\n *   const coreApp = useApp();\n *   const customState = useSelector(state => state.myCustom);\n *\n *   return (\n *     <MyContext.Provider value={{ ...coreApp, ...customState }}>\n *       {children}\n *     </MyContext.Provider>\n *   );\n * }\n */\nconst AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n    const state = useSelector((appState) => appState.app);\n    const dispatch = useDispatch();\n    const [connected, setConnected] = useState(false);\n\n    // Network connectivity monitoring\n    useEffect(() => {\n        const unsubscribe = NetInfo.addEventListener((internetState) => {\n            setConnected(!!internetState.isInternetReachable);\n        });\n        return () => unsubscribe();\n    }, []);\n\n    // Core context value - minimal and essential only\n    const value = useMemo<AppContextValue>(\n        () => ({\n            auth: state.auth,\n            user: state.user,\n            colorMode: state.colorMode,\n            connected,\n            setAuth: (payload) => dispatch(actions.setAuth(payload)),\n            setColorMode: (payload) => dispatch(actions.setColorMode(payload)),\n            setUser: (payload) => dispatch(actions.setUser(payload)),\n            clearAuth: () => dispatch(actions.clearAuth()),\n        }),\n        [state.auth, state.user, connected, dispatch]\n    );\n\n    return (\n        <AppContext.Provider value={value}>\n            {children}\n        </AppContext.Provider>\n    );\n};\n\nexport default AppProvider;\n","import { TypedUseSelectorHook, useSelector as Selector } from 'react-redux';\nimport { RootState, AppDispatch } from '../store';\n\nconst useSelector: TypedUseSelectorHook<RootState> = Selector;\n\nexport default useSelector;\n","import { AppDispatch } from '../store';\nimport { useDispatch } from 'react-redux';\n\nexport default () => useDispatch<AppDispatch>();\n","import { PayloadAction, createSlice } from '@reduxjs/toolkit';\n\n/**\n * Minimal core app state - essentials only\n * Apps can extend this with their own fields via custom reducers\n */\nexport interface CoreAppState {\n  auth: {\n    accessToken: string;\n    refreshToken: string;\n    userId?: string;\n  };\n  user: any; // Generic user object - apps define their own User type\n  colorMode: \"light\" | \"dark\";\n}\n\nconst initialState: CoreAppState = {\n  auth: {\n    accessToken: '',\n    refreshToken: '',\n    userId: undefined,\n  },\n  user: null,\n  colorMode: \"light\",\n};\n\n/**\n * Core app reducer with minimal essential state\n * This provides the foundation that all apps need\n */\nconst appSlice = createSlice({\n  name: 'app',\n  initialState,\n  reducers: {\n    /**\n     * Set auth tokens and customer ID\n     * Accepts partial updates to merge with existing auth state\n     */\n    setAuth(state, action: PayloadAction<Partial<CoreAppState['auth']>>) {\n      state.auth = { ...state.auth, ...action.payload };\n    },\n\n    /**\n     * Set user data\n     * Apps define their own user structure\n     */\n    setUser(state, action: PayloadAction<any>) {\n      state.user = action.payload;\n    },\n\n    setColorMode(state, action: PayloadAction<CoreAppState[\"colorMode\"]>) {\n      state.colorMode = action.payload;\n    },\n\n    /**\n     * Clear authentication state\n     * Resets both auth and user to initial values\n     */\n    clearAuth(state) {\n      state.auth = initialState.auth;\n      state.user = null;\n    },\n  },\n});\n\nexport const actions = appSlice.actions;\nexport default appSlice.reducer;\n\n/**\n * Legacy type for backward compatibility\n * @deprecated Apps should create their own custom reducers instead\n */\nexport interface LegacyAppState extends CoreAppState {\n  /** @deprecated Create a custom reducer for app-specific fields */\n  registered?: boolean;\n  /** @deprecated Create a custom reducer for app-specific fields */\n  deviceId?: any;\n  /** @deprecated Create a custom reducer for app-specific fields */\n  email?: string;\n  /** @deprecated Create a custom reducer for app-specific fields */\n  image?: string;\n  /** @deprecated Create a custom reducer for app-specific fields */\n  defaultPassword?: boolean;\n  /** @deprecated Create a custom reducer for app-specific fields */\n  biometric?: boolean;\n  /** @deprecated Create a custom reducer for app-specific fields */\n  visibility?: any;\n}\n","import {createSlice, PayloadAction} from \"@reduxjs/toolkit\";\n\n/**\n * Cache entry structure with TTL support\n */\nexport interface CacheEntry {\n  data: any;\n  timestamp: number;\n  expiresAt?: number;\n  staleAt?: number;\n}\n\nexport interface CacheState {\n  [key: string]: CacheEntry | any; // any for backward compatibility\n}\n\nexport interface CacheMetadata {\n  accessOrder: string[];\n  maxSize: number;\n}\n\n// Separate metadata state (not serialized in Redux)\nconst metadata: CacheMetadata = {\n  accessOrder: [],\n  maxSize: 100, // Default LRU limit\n};\n\nconst initialState: CacheState = {};\n\nconst cacheSlice = createSlice({\n    name: 'cache',\n    initialState,\n    reducers: {\n        init(state, action: PayloadAction<any>) {\n            state[action.payload.key] = {\n                ...(state[action.payload.key]||{}),\n                ...action.payload.value,\n            }\n        },\n        set(state, action: PayloadAction<{ key:string, value:any, ttl?:number, staleTime?:number }>) {\n            const timestamp = Date.now();\n            const { key, value, ttl, staleTime } = action.payload;\n            \n            // Update LRU access order\n            updateAccessOrder(state, key);\n            \n            // Create cache entry with TTL support\n            const entry: CacheEntry = {\n              data: value,\n              timestamp,\n              expiresAt: ttl ? timestamp + ttl : undefined,\n              staleAt: staleTime !== undefined ? timestamp + staleTime : undefined,\n            };\n            \n            state[key] = entry;\n        },\n        prepend(state, action: PayloadAction<{ key:string, value:any[] }>) {\n            const timestamp = new Date().getTime()\n            state[action.payload.key] = action.payload.value.map((data:any)=>({...data, timestamp})).concat(state[action.payload.key]||[])\n        },\n        append(state, action: PayloadAction<{ key:string, value:any[] }>) {\n            const timestamp = new Date().getTime()\n            state[action.payload.key] = (state[action.payload.key]||[]).concat(action.payload.value.map((data:any)=>({...data, timestamp})))\n        },\n        paginate(state, action: PayloadAction<{ key:string, data:any, paginationKey:string }>) {\n            const timestamp = new Date().getTime()\n            const {key, data, paginationKey} = action.payload\n            state[key] = {\n                ...data,\n                [paginationKey]: [...state[key][paginationKey], ...data[paginationKey]],\n                timestamp\n            }\n        },\n        remove(state, action: PayloadAction<string>) {\n            delete state[action.payload];\n            /*const spr:any = {...state}\n            delete spr[action.payload];\n            state = spr*/\n        },\n        clear:()=> initialState,\n        \n        // New action to delete a specific cache entry\n        delete(state, action: PayloadAction<{ key:string }>) {\n            const { key } = action.payload;\n            delete state[key];\n            // Remove from access order\n            const index = metadata.accessOrder.indexOf(key);\n            if (index > -1) {\n                metadata.accessOrder.splice(index, 1);\n            }\n        },\n\n    },\n});\n\n/**\n * Updates LRU access order and evicts if necessary\n */\nfunction updateAccessOrder(state: CacheState, key: string) {\n  // Remove key if it exists\n  const index = metadata.accessOrder.indexOf(key);\n  if (index > -1) {\n    metadata.accessOrder.splice(index, 1);\n  }\n  \n  // Add to end (most recent)\n  metadata.accessOrder.push(key);\n  \n  // Evict oldest if over limit\n  if (metadata.accessOrder.length > metadata.maxSize) {\n    const evictKey = metadata.accessOrder.shift();\n    if (evictKey) {\n      delete state[evictKey];\n    }\n  }\n}\n\n/**\n * Set the maximum cache size for LRU eviction\n */\nexport function setMaxCacheSize(size: number) {\n  metadata.maxSize = size;\n}\n\n/**\n * Get current cache metadata (for debugging)\n */\nexport function getCacheMetadata(): Readonly<CacheMetadata> {\n  return { ...metadata };\n}\n\nexport const actions = cacheSlice.actions;\nexport default cacheSlice.reducer;\n","import {createSlice, PayloadAction} from \"@reduxjs/toolkit\";\n\nconst initialState:any = {};\n\nconst threadSlice = createSlice({\n    name: 'thread',\n    initialState,\n    reducers: {\n        set(state, action: PayloadAction<{ key:string, value:{ loading:boolean, error?:string, status?:number } }>) {\n            state[action.payload.key] = action.payload.value\n        },\n        remove(state, action: PayloadAction<string>) {\n            delete state[action.payload];\n            /*const spr:any = {...state}\n            delete spr[action.payload];\n            state = spr*/\n        },\n        clear:()=> initialState\n\n    },\n});\n\nexport const actions = threadSlice.actions;\nexport default threadSlice.reducer;\n","import { useCallback } from \"react\";\nimport { useApp } from \"store/contexts/app-context\";\nimport useDispatch from \"./use-dispatch\";\nimport useSelector from \"./use-selector\";\nimport { actions } from \"store/reducers/cache-reducer\";\nimport { Route } from \"types\";\nimport { parseRoute } from \"hooks/utils\";\nimport { CacheOperations } from \"./types\";\n\n/**\n * Helper function to get the ID from an item\n * Checks both _id (MongoDB) and id (standard) fields\n */\nconst getItemId = (item: any, idRef?:string): string | undefined => {\n    return item[idRef] || item?._id || item?.id;\n};\n\n/**\n * Custom hook for cache operations\n * Provides functions to get, set, and manipulate cached data\n * @returns CacheOperations interface with all cache manipulation functions\n */\nconst useCache = (): CacheOperations => {\n    const dispatch = useDispatch();\n    const { auth: { userId } } = useApp();\n    const cacheState = useSelector((state) => state.cache);\n\n    /**\n     * Parses a route and generates cache key with context\n     */\n    const getContext = useCallback(\n        (route: Route, variables?: Record<string, any>) => {\n            return parseRoute(route, variables, userId);\n        },\n        [userId]\n    );\n\n    /**\n     * Generates a cache key for a route and variables\n     */\n    const getKey = useCallback(\n        (route: Route, variables?: Record<string, any>) => {\n            const { key } = getContext(route, variables);\n            return key;\n        },\n        [getContext]\n    );\n\n    /**\n     * Gets cached data for a specific key\n     */\n    const getData = useCallback(\n        (key: string) => {\n            return cacheState[key];\n        },\n        [cacheState]\n    );\n\n    /**\n     * Sets cache data for a specific key\n     */\n    const setCache = useCallback(\n        (key: string, value: any) => {\n            dispatch(actions.set({ key, value }));\n        },\n        [dispatch]\n    );\n\n    /**\n     * Updates cache data (alias for setCache)\n     */\n    const update = useCallback(\n        (key: string, value: any) => {\n            setCache(key, value);\n        },\n        [setCache]\n    );\n\n    /**\n     * Updates a single item in a cached array\n     */\n    const updateItem = useCallback(\n        (key: string, id: string, value: any, idRef?:string) => {\n            const cache = cacheState[key];\n            if (Array.isArray(cache)) {\n                const index = cache.findIndex((item: any) => getItemId(item, idRef) === id);\n                if (index !== -1) {\n                    const updated = [...cache];\n                    updated[index] = { ...updated[index], ...value };\n                    setCache(key, updated);\n                }\n            }\n        },\n        [cacheState, setCache]\n    );\n\n    /**\n     * Gets a single item from a cached array\n     */\n    const getItem = useCallback(\n        (key: string, id: string, idRef?:string) => {\n            const cache = cacheState[key];\n            if (Array.isArray(cache)) {\n                return cache.find((item: any) => getItemId(item, idRef) === id);\n            }\n            return undefined;\n        },\n        [cacheState]\n    );\n\n    /**\n     * Updates a single property in a cached object\n     */\n    const updateValue = useCallback(\n        (key: string, arg: string, value: any) => {\n            const cache = cacheState[key];\n            if (!Array.isArray(cache) && typeof cache === \"object\") {\n                setCache(key, { ...cache, [arg]: value });\n            }\n        },\n        [cacheState, setCache]\n    );\n\n    /**\n     * Updates multiple properties in a cached object\n     */\n    const updateValues = useCallback(\n        (key: string, values: Record<string, any>) => {\n            const cache = cacheState[key];\n            if (!Array.isArray(cache) && typeof cache === \"object\") {\n                setCache(key, { ...cache, ...values });\n            }\n        },\n        [cacheState, setCache]\n    );\n\n    /**\n     * Prepends data to the beginning of a cached array\n     */\n    const prepend = useCallback(\n        (key: string, data: any) => {\n            const cache = cacheState[key];\n            if (Array.isArray(cache)) {\n                setCache(key, [data, ...cache]);\n            } else {\n                setCache(key, [data]);\n            }\n        },\n        [cacheState, setCache]\n    );\n\n    /**\n     * Updates an item if it exists, or prepends it if it doesn't\n     */\n    const updateOrPrepend = useCallback(\n        (key: string, data: any, idRef?:string) => {\n            const cache = cacheState[key];\n            if (Array.isArray(cache)) {\n                const dataId = getItemId(data, idRef);\n                const index = cache.findIndex((item: any) => getItemId(item, idRef) === dataId);\n                if (index !== -1) {\n                    const updated = [...cache];\n                    updated[index] = { ...updated[index], ...data };\n                    setCache(key, updated);\n                } else {\n                    setCache(key, [data, ...cache]);\n                }\n            } else {\n                setCache(key, [data]);\n            }\n        },\n        [cacheState, setCache]\n    );\n\n    /**\n     * Appends data to the end of a cached array\n     */\n    const append = useCallback(\n        (key: string, data: any) => {\n            const cache = cacheState[key];\n            if (Array.isArray(cache)) {\n                setCache(key, [...cache, data]);\n            } else {\n                setCache(key, [data]);\n            }\n        },\n        [cacheState, setCache]\n    );\n\n    /**\n     * Deletes an item from a cached array\n     */\n    const deleteItem = useCallback(\n        (key: string, id: string, idRef?:string) => {\n            const cache = cacheState[key];\n            if (Array.isArray(cache)) {\n                setCache(key, cache.filter((item: any) => getItemId(item, idRef) !== id));\n            }\n        },\n        [cacheState, setCache]\n    );\n\n    /**\n     * Invalidates a specific cache entry\n     */\n    const invalidate = useCallback(\n        (key: string) => {\n            dispatch(actions.delete({ key }));\n        },\n        [dispatch]\n    );\n\n    /**\n     * Invalidates all queries matching a pattern\n     * @param pattern - String prefix or RegExp pattern\n     */\n    const invalidateQueries = useCallback(\n        (pattern: string | RegExp) => {\n            const regex =\n                typeof pattern === \"string\" ? new RegExp(`^${pattern}`) : pattern;\n\n            const keysToInvalidate = Object.keys(cacheState).filter((k) =>\n                regex.test(k)\n            );\n\n            keysToInvalidate.forEach((key) => {\n                dispatch(actions.delete({ key }));\n            });\n        },\n        [cacheState, dispatch]\n    );\n\n    /**\n     * Invalidates all cache entries\n     */\n    const invalidateAll = useCallback(() => {\n        dispatch(actions.clear());\n    }, [dispatch]);\n\n    return {\n        getItem,\n        setCache,\n        getKey,\n        getContext,\n        getData,\n        update,\n        updateValue,\n        updateValues,\n        updateItem,\n        deleteItem,\n        prepend,\n        append,\n        updateOrPrepend,\n        invalidate,\n        invalidateQueries,\n        invalidateAll,\n    };\n};\n\nexport default useCache;\n","const PATHS = {\n  login: 'POST:/Authenticate',\n  biometricAuth: 'POST:/TouchAuthenticate',\n  generateOtp: 'POST:/GenerateOTP',\n  validateOtp: 'POST:/ValidateOTP',\n  register: 'POST:/CreateNewAccount',\n  forgot: 'POST:/ForgotPassword'\n};\nexport default PATHS;","import { Route } from \"../../types\";\nimport { Method } from \"../../utils/service\";\nimport PATHS from \"../../paths\";\nimport { getHttpConfig } from \"../../utils/service\";\n\nexport interface ParsedRoute {\n  path: string;\n  method: Method;\n  key: string;\n  rawPath: string;\n}\n\n/**\n * Parses a route string and replaces path parameters with actual values\n * @param route - The route key from PATHS or a raw route string\n * @param variables - Object containing path parameters and query variables\n * @param customerId - The customer ID to inject into paths\n * @returns ParsedRoute object with path, method, key, and rawPath\n */\nexport function parseRoute(\n  route: Route,\n  variables: Record<string, any> = {},\n  customerId?: string\n): ParsedRoute {\n  const config = getHttpConfig();\n  \n  // Merge default PATHS with custom paths (custom takes precedence)\n  const allPaths = { \n    ...PATHS, \n    ...(config.paths || {}) \n  };\n  \n  const rawPath = allPaths[route] || route;\n  const [method, pathTemplate] = rawPath.split(\":/\");\n  \n  // Clone variables to avoid mutation\n  const variablesCopy = { ...variables };\n  \n  // Replace path parameters\n  const path = \"/\" + pathTemplate.replace(/:\\w+/g, (matched: string) => {\n    const params = { customerId, ...variablesCopy };\n    const paramName = matched.replace(/\\W/g, \"\");\n    \n    // Remove from variables copy so it's not added to query string\n    delete variablesCopy[paramName];\n    \n    return params[paramName as keyof typeof params] || matched;\n  });\n  \n  // Generate cache key\n  const key = path + JSON.stringify(variablesCopy);\n  \n  return {\n    path,\n    method: (method as Method) || \"GET\",\n    key,\n    rawPath,\n  };\n}\n\n/**\n * Generates a cache key for a given route and variables\n * @param route - The route key from PATHS\n * @param variables - Object containing route variables\n * @param customerId - The customer ID\n * @returns Cache key string\n */\nexport function generateCacheKey(\n  route: Route,\n  variables: Record<string, any> = {},\n  customerId?: string\n): string {\n  const { key } = parseRoute(route, variables, customerId);\n  return key;\n}\n\n","/**\n * Standard error response structure\n */\nexport interface ErrorResponse {\n  error: string;\n  status?: number;\n}\n\n/**\n * Standard success response structure\n */\nexport interface SuccessResponse<T = any> {\n  data: T;\n  status: number;\n}\n\n/**\n * Combined response type\n */\nexport type ApiResponse<T = any> = ErrorResponse | SuccessResponse<T>;\n\n/**\n * Extracts error message from various response formats\n * @param response - The API response object\n * @param defaultMessage - Default error message if none found\n * @returns Error message string\n */\nexport function extractErrorMessage(\n  response: any,\n  defaultMessage: string = \"Oops! an error occurred\"\n): string {\n  if (typeof response === \"string\") {\n    return response;\n  }\n  \n  // Try common error paths\n  return (\n    response?.data?.data?.ResponseDescription ||\n    response?.data?.ResponseDescription ||\n    response?.data?.error ||\n    response?.error ||\n    response?.message ||\n    defaultMessage\n  );\n}\n\n/**\n * Checks if the response status indicates success\n * @param status - HTTP status code\n * @returns True if successful status code\n */\nexport function isSuccessStatus(status: number): boolean {\n  return [200, 201].includes(status);\n}\n\n/**\n * Checks if the response status indicates unauthorized/not found\n * @param status - HTTP status code\n * @returns True if status is 401 or 404\n */\nexport function isAuthError(status: number): boolean {\n  return [401, 404].includes(status);\n}\n\n/**\n * Creates a standardized error response\n * @param error - Error message or Error object\n * @param status - HTTP status code\n * @returns ErrorResponse object\n */\nexport function createErrorResponse(\n  error: string | Error,\n  status: number = 500\n): ErrorResponse {\n  const message = typeof error === \"string\" ? error : error.message;\n  return {\n    error: message || \"Oops! an error occurred\",\n    status,\n  };\n}\n\n/**\n * Creates a standardized success response\n * @param data - Response data\n * @param status - HTTP status code\n * @returns SuccessResponse object\n */\nexport function createSuccessResponse<T>(\n  data: T,\n  status: number = 200\n): SuccessResponse<T> {\n  return {\n    data,\n    status,\n  };\n}\n\n/**\n * Checks if an error is an abort/cancellation error\n * @param error - The error to check\n * @returns True if the error is from request cancellation\n */\nexport function isAbortError(error: any): boolean {\n  if (!error) return false;\n\n  return (\n    error.name === \"AbortError\" ||\n    error.name === \"CanceledError\" ||\n    error.code === \"ERR_CANCELED\" ||\n    error.message?.includes(\"abort\") ||\n    error.message?.includes(\"cancel\")\n  );\n}\n\n/**\n * Checks if an error is a cancellation error (alias for isAbortError)\n * @param error - The error to check\n * @returns True if the error is from request cancellation\n */\nexport function isCancelError(error: any): boolean {\n  return isAbortError(error);\n}\n\n/**\n * Determines if a request should be retried based on the error\n * @param error - The error to check\n * @returns True if the request should be retried\n */\nexport function shouldRetry(error: any): boolean {\n  // Don't retry if it was cancelled\n  if (isAbortError(error)) {\n    return false;\n  }\n\n  // Don't retry client errors (4xx)\n  if (error.response?.status >= 400 && error.response?.status < 500) {\n    return false;\n  }\n\n  // Don't retry auth errors\n  if (isAuthError(error.response?.status)) {\n    return false;\n  }\n\n  // Retry on network errors or 5xx server errors\n  return true;\n}\n\n","import React, {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\n\nimport NetInfo from '@react-native-community/netinfo';\n\ntype Props = {\n  connected: boolean;\n};\n\nconst defaultValue: any = {};\n\nconst SocketContext = createContext<Props>(defaultValue);\nexport const useSocket = () => useContext(SocketContext);\n\nconst SocketProvider: React.FC<any> = ({children}) => {\n  const [connected, setConnected] = useState(false);\n\n  useEffect(() => {\n    const unsubscribe = NetInfo.addEventListener(state => {\n      if (state.isInternetReachable) {\n        setConnected(true);\n      } else {\n        setConnected(false);\n      }\n    });\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  return (\n    <SocketContext.Provider\n      value={{\n        connected,\n      }}>\n      {children}\n    </SocketContext.Provider>\n  );\n};\n\nexport default SocketProvider;\n","/**\n * Hook-related constants\n */\n\n/**\n * Network request timeout in milliseconds\n */\nexport const NETWORK_TIMEOUT = 10000; // 10 seconds\n\n/**\n * Default error messages\n */\nexport const ERROR_MESSAGES = {\n  GENERIC: \"Oops! an error occurred\",\n  NETWORK: \"Network error occurred\",\n  TIMEOUT: \"Request timed out\",\n  SESSION_EXPIRED: \"Session expired! kindly login\",\n  UNAUTHORIZED: \"Unauthorized access\",\n} as const;\n\n/**\n * HTTP status codes\n */\nexport const STATUS_CODES = {\n  OK: 200,\n  CREATED: 201,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  SERVER_ERROR: 500,\n} as const;\n\n/**\n * Cache TTL constants\n */\nexport const DEFAULT_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\nexport const DEFAULT_STALE_TIME = 0; // immediately stale (always refetch)\nexport const MAX_CACHE_SIZE = 100; // LRU limit\n\n/**\n * Network policies for queries\n */\nexport type NetworkPolicy =\n  | \"network-and-cache\"\n  | \"cache-only\"\n  | \"network-only\"\n  | \"cache-first\"\n  | \"stale-while-revalidate\"; // NEW\n\n/**\n * Concat strategies for fetchMore\n */\nexport type ConcatStrategy = \"start\" | \"end\" | \"pagination\";\n\n","/**\n * Request Deduplication System\n * Prevents duplicate in-flight requests with the same key\n * All components requesting the same data share the same Promise\n */\n\nconst inFlightRequests = new Map<string, Promise<any>>();\n\n/**\n * Gets an existing in-flight request or creates a new one\n * @param key - Unique identifier for the request\n * @param requestFn - Function that performs the actual request\n * @returns Promise that resolves with the request result\n * \n * @example\n * const result = await getOrCreateRequest('users-123', () => \n *   http('/users/123', 'GET')\n * );\n */\nexport function getOrCreateRequest<T>(\n  key: string,\n  requestFn: () => Promise<T>\n): Promise<T> {\n  // Check if request is already in flight\n  if (inFlightRequests.has(key)) {\n    return inFlightRequests.get(key)!;\n  }\n\n  // Create new request and store it\n  const promise = requestFn()\n    .finally(() => {\n      // Clean up after request completes (success or error)\n      inFlightRequests.delete(key);\n    });\n\n  inFlightRequests.set(key, promise);\n  return promise;\n}\n\n/**\n * Manually cancel/remove a request from the in-flight queue\n * Useful when aborting a request\n * @param key - The request key to cancel\n */\nexport function cancelRequest(key: string): void {\n  inFlightRequests.delete(key);\n}\n\n/**\n * Check if a request is currently in flight\n * @param key - The request key to check\n * @returns True if request is in progress\n */\nexport function isRequestInFlight(key: string): boolean {\n  return inFlightRequests.has(key);\n}\n\n/**\n * Get the number of in-flight requests\n * Useful for debugging and monitoring\n */\nexport function getInFlightCount(): number {\n  return inFlightRequests.size;\n}\n\n/**\n * Clear all in-flight requests\n * Useful for testing or when resetting application state\n */\nexport function clearAllRequests(): void {\n  inFlightRequests.clear();\n}\n\n","/**\n * Cache Helper Utilities\n * Functions for validating cache freshness, expiry, and staleness\n */\n\nimport { CacheEntry } from \"../../store/reducers/cache-reducer\";\n\n/**\n * Checks if a cache entry has expired based on its TTL\n * @param entry - The cache entry to check\n * @returns True if the cache has expired\n * \n * @example\n * const entry = { data: {...}, timestamp: Date.now(), expiresAt: Date.now() - 1000 };\n * isCacheExpired(entry); // true\n */\nexport function isCacheExpired(entry: CacheEntry | any): boolean {\n  // Handle backward compatibility - check if entry is a CacheEntry\n  if (!entry || typeof entry !== 'object') {\n    return false;\n  }\n  \n  // If it's a new-style entry with expiresAt\n  if ('expiresAt' in entry && entry.expiresAt) {\n    return Date.now() > entry.expiresAt;\n  }\n  \n  // Old-style entries never expire\n  return false;\n}\n\n/**\n * Checks if a cache entry is stale and should be refetched\n * @param entry - The cache entry to check\n * @returns True if the cache is stale\n * \n * @example\n * const entry = { data: {...}, timestamp: Date.now(), staleAt: Date.now() - 1000 };\n * isCacheStale(entry); // true\n */\nexport function isCacheStale(entry: CacheEntry | any): boolean {\n  // Handle backward compatibility\n  if (!entry || typeof entry !== 'object') {\n    return true; // No cache = stale\n  }\n  \n  // If it's a new-style entry with staleAt\n  if ('staleAt' in entry) {\n    // If staleAt is undefined, never stale (infinite fresh time)\n    if (entry.staleAt === undefined) {\n      return false;\n    }\n    return Date.now() > entry.staleAt;\n  }\n  \n  // Old-style entries are always considered stale (safe default)\n  return true;\n}\n\n/**\n * Checks if a cache entry is fresh (not expired and not stale)\n * @param entry - The cache entry to check\n * @returns True if the cache is fresh\n * \n * @example\n * const entry = { \n *   data: {...}, \n *   timestamp: Date.now(), \n *   expiresAt: Date.now() + 10000,\n *   staleAt: Date.now() + 5000\n * };\n * isCacheFresh(entry); // true\n */\nexport function isCacheFresh(entry: CacheEntry | any): boolean {\n  return !isCacheExpired(entry) && !isCacheStale(entry);\n}\n\n/**\n * Extracts data from a cache entry, handling both new and old formats\n * @param entry - The cache entry\n * @returns The actual data\n */\nexport function getCacheData(entry: CacheEntry | any): any {\n  if (!entry) {\n    return undefined;\n  }\n  \n  // New-style entry with 'data' property\n  if ('data' in entry && 'timestamp' in entry) {\n    return entry.data;\n  }\n  \n  // Old-style entry (data is the entry itself)\n  return entry;\n}\n\n/**\n * Creates a cache entry with TTL and stale time\n * @param data - The data to cache\n * @param ttl - Time to live in milliseconds (optional)\n * @param staleTime - Time until stale in milliseconds (optional)\n * @returns A properly formatted cache entry\n */\nexport function createCacheEntry(\n  data: any,\n  ttl?: number,\n  staleTime?: number\n): CacheEntry {\n  const timestamp = Date.now();\n  return {\n    data,\n    timestamp,\n    expiresAt: ttl ? timestamp + ttl : undefined,\n    staleAt: staleTime !== undefined ? timestamp + staleTime : undefined,\n  };\n}\n\n/**\n * Gets the age of a cache entry in milliseconds\n * @param entry - The cache entry\n * @returns Age in milliseconds\n */\nexport function getCacheAge(entry: CacheEntry | any): number {\n  if (!entry || !entry.timestamp) {\n    return Infinity;\n  }\n  return Date.now() - entry.timestamp;\n}\n\n/**\n * Checks if cache entry exists and is not expired\n * @param entry - The cache entry\n * @returns True if cache can be used\n */\nexport function canUseCache(entry: CacheEntry | any): boolean {\n  return entry && !isCacheExpired(entry);\n}\n\n","/**\n * Extracts data from API response based on configured data path\n * @param response - The Axios response object (res.data)\n * @param dataPath - The path to extract (e.g., \"data\" for res.data.data, \"\" for res.data)\n * @returns The extracted data\n */\nexport const extractResponseData = (response: any, dataPath?: string): any => {\n  if (!dataPath) {\n    return response;\n  }\n  \n  const path = dataPath.trim();\n  if (!path) {\n    return response;\n  }\n  \n  // Support dot notation for nested paths (e.g., \"data.items\")\n  return path.split('.').reduce((obj, key) => obj?.[key], response);\n};\n\n","import React, { createContext, useContext, useMemo, ReactNode, useEffect, useState, useCallback } from 'react';\nimport { AlphaConfig, DEFAULT_CONFIG } from '../../config';\nimport { setMaxCacheSize } from '../reducers/cache-reducer';\nimport { enableGlobalDebug, disableGlobalDebug } from 'hooks/utils/debug-logger';\nimport { setHttpConfig } from 'utils/service';\nimport { setEncryptionConfig } from 'utils/crypto';\n\ninterface ConfigContextType {\n    config: AlphaConfig;\n    updateConfig: (newConfig: Partial<AlphaConfig>) => void;\n}\n\nconst ConfigContext = createContext<ConfigContextType | undefined>(undefined);\n\ninterface ConfigProviderProps {\n    config: AlphaConfig;\n    children: ReactNode;\n}\n\n/**\n * Configuration Provider\n * Manages and distributes Alpha configuration throughout the app\n * Supports dynamic config updates via updateConfig function\n */\nexport const ConfigProvider: React.FC<ConfigProviderProps> = ({ config: initialConfig, children }) => {\n    // Initialize with merged config\n    const [internalConfig, setInternalConfig] = useState<AlphaConfig>(() => ({\n        ...DEFAULT_CONFIG,\n        ...initialConfig,\n        cache: {\n            ...DEFAULT_CONFIG.cache,\n            ...initialConfig.cache,\n        },\n        retry: {\n            ...DEFAULT_CONFIG.retry,\n            ...initialConfig.retry,\n        },\n    }));\n\n    // Update internal config when prop changes (allows parent control)\n    useEffect(() => {\n        setInternalConfig(prev => ({\n            ...prev,\n            ...initialConfig,\n            cache: {\n                ...prev.cache,\n                ...initialConfig.cache,\n            },\n            retry: {\n                ...prev.retry,\n                ...initialConfig.retry,\n            },\n        }));\n    }, [initialConfig]);\n\n    // Function to update config dynamically from child components\n    const updateConfig = useCallback((newConfig: Partial<AlphaConfig>) => {\n        setInternalConfig(prev => {\n            const updated: AlphaConfig = {\n                ...prev,\n                ...newConfig,\n            };\n\n            // Deep merge nested objects\n            if (newConfig.cache !== undefined) {\n                updated.cache = {\n                    ...prev.cache,\n                    ...newConfig.cache,\n                };\n            }\n\n            if (newConfig.retry !== undefined) {\n                updated.retry = {\n                    ...prev.retry,\n                    ...newConfig.retry,\n                };\n            }\n\n            // Handle encryption config explicitly\n            if (newConfig.encryption !== undefined) {\n                updated.encryption = newConfig.encryption;\n            }\n\n            // Handle defaultEncryption explicitly\n            if (newConfig.defaultEncryption !== undefined) {\n                updated.defaultEncryption = newConfig.defaultEncryption;\n            }\n\n            return updated;\n        });\n    }, []);\n\n    // Apply cache max size\n    useEffect(() => {\n        if (internalConfig.cache?.maxSize) {\n            setMaxCacheSize(internalConfig.cache.maxSize);\n        }\n    }, [internalConfig.cache?.maxSize]);\n\n    // Apply debug mode\n    useEffect(() => {\n        if (internalConfig.debug) {\n            enableGlobalDebug();\n        } else {\n            disableGlobalDebug();\n        }\n    }, [internalConfig.debug]);\n\n    // Update HTTP client when config changes\n    useEffect(() => {\n        setHttpConfig(internalConfig);\n    }, [internalConfig]);\n\n    // Update encryption config when it changes\n    useEffect(() => {\n        if (internalConfig.encryption) {\n            setEncryptionConfig(internalConfig.encryption);\n        }\n    }, [internalConfig.encryption]);\n\n    const value = useMemo(\n        () => ({ config: internalConfig, updateConfig }),\n        [internalConfig, updateConfig]\n    );\n\n    return <ConfigContext.Provider value={value}>{children}</ConfigContext.Provider>;\n};\n\n/**\n * Hook to access and update Alpha configuration\n * Returns a tuple [config, setConfig] similar to useState\n *\n * @example\n * ```typescript\n * // Read and write\n * const [config, setConfig] = useAlphaConfig();\n * setConfig({ baseUrl: 'https://new-api.com' });\n *\n * // Read only\n * const [config] = useAlphaConfig();\n *\n * // Write only\n * const [, setConfig] = useAlphaConfig();\n * ```\n *\n * @returns Tuple of [config, updateConfig function]\n */\nexport function useAlphaConfig(): [AlphaConfig, (config: Partial<AlphaConfig>) => void] {\n    const context = useContext(ConfigContext);\n\n    if (!context) {\n        // Return defaults with no-op setter if used outside provider\n        const noopSetter = () => {\n            console.warn('[rn-alpha-hooks] useAlphaConfig: Cannot update config outside AlphaProvider');\n        };\n        return [DEFAULT_CONFIG, noopSetter];\n    }\n\n    return [context.config, context.updateConfig];\n}\n\nexport default ConfigProvider;\n\n","/**\n * Debug Logger for Query/Mutation Hooks\n * Provides detailed logging for debugging cache hits, network requests, and timing\n */\n\nexport interface QueryDebugInfo {\n  key: string;\n  action: 'cache-hit' | 'cache-miss' | 'fetch-start' | 'fetch-success' | 'fetch-error' | 'invalidate';\n  timestamp: number;\n  duration?: number;\n  data?: any;\n  error?: any;\n  variables?: any;\n}\n\n/**\n * Query Debugger Class\n * Provides structured logging for debugging data fetching\n */\nexport class QueryDebugger {\n  private enabled: boolean;\n  private prefix: string;\n\n  constructor(enabled: boolean, prefix: string = '[Query]') {\n    this.enabled = enabled;\n    this.prefix = prefix;\n  }\n\n  /**\n   * Log a cache hit\n   */\n  logCacheHit(key: string, data: any) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} ðŸŽ¯ Cache HIT`, {\n      key,\n      dataSize: this.getDataSize(data),\n      timestamp: new Date().toISOString(),\n    });\n\n    if (data) {\n      console.log(`${this.prefix} Data:`, data);\n    }\n  }\n\n  /**\n   * Log a cache miss\n   */\n  logCacheMiss(key: string) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} âŒ Cache MISS`, {\n      key,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log the start of a fetch request\n   */\n  logFetchStart(key: string, variables?: any) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} ðŸš€ Fetching`, {\n      key,\n      variables,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log a successful fetch\n   */\n  logFetchSuccess(key: string, duration?: number, data?: any) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} âœ… Success`, {\n      key,\n      duration: duration ? `${duration.toFixed(2)}ms` : 'N/A',\n      dataSize: this.getDataSize(data),\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log a fetch error\n   */\n  logFetchError(key: string, error: any, duration?: number) {\n    if (!this.enabled) return;\n\n    console.error(`${this.prefix} âŒ Error`, {\n      key,\n      error: error?.message || error,\n      duration: duration ? `${duration.toFixed(2)}ms` : 'N/A',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log cache invalidation\n   */\n  logInvalidate(key: string | RegExp) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} ðŸ”„ Invalidating`, {\n      pattern: key.toString(),\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log network policy decision\n   */\n  logPolicy(key: string, policy: string, decision: string) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} ðŸ“‹ Policy`, {\n      key,\n      policy,\n      decision,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log cache expiry check\n   */\n  logCacheExpiry(key: string, isExpired: boolean, isStale: boolean) {\n    if (!this.enabled) return;\n\n    console.log(`${this.prefix} â° Cache Status`, {\n      key,\n      expired: isExpired,\n      stale: isStale,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Log request deduplication\n   */\n  logDeduplication(key: string, isDuplicate: boolean) {\n    if (!this.enabled) return;\n\n    if (isDuplicate) {\n      console.log(`${this.prefix} ðŸ”— Request Deduplicated`, {\n        key,\n        message: 'Using existing in-flight request',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  /**\n   * Get the size of data (array length or object keys)\n   */\n  private getDataSize(data: any): string {\n    if (!data) return '0';\n    if (Array.isArray(data)) return `${data.length} items`;\n    if (typeof data === 'object') return `${Object.keys(data).length} keys`;\n    return 'scalar';\n  }\n}\n\n/**\n * Global debug toggle\n * Can be enabled at runtime for debugging\n */\nlet globalDebugEnabled = false;\n\nexport function enableGlobalDebug() {\n  globalDebugEnabled = true;\n}\n\nexport function disableGlobalDebug() {\n  globalDebugEnabled = false;\n}\n\nexport function isGlobalDebugEnabled(): boolean {\n  return globalDebugEnabled;\n}\n\n/**\n * Create a debugger instance\n */\nexport function createDebugger(enabled?: boolean, prefix?: string): QueryDebugger {\n  return new QueryDebugger(enabled ?? globalDebugEnabled, prefix);\n}\n\n","import CryptoJS from \"react-native-crypto-js\";\n\n/**\n * Encryption configuration interface\n */\nexport interface EncryptionConfig {\n  key: string;\n  iv: string;\n}\n\n/**\n * Default encryption config (for development only)\n * âš ï¸ NEVER use these keys in production!\n */\nconst DEFAULT_CONFIG: EncryptionConfig = {\n  key: \"2vn!H3KXgX-TxvkD\", // Default for development\n  iv: \"%x%97Uw@*A2xWaUJ\"   // Default for development\n};\n\n/**\n * Current encryption configuration\n */\nlet currentConfig: EncryptionConfig = { ...DEFAULT_CONFIG };\n\n/**\n * Flag to track if default keys warning has been shown\n */\nlet hasWarnedAboutDefaultKeys = false;\n\n/**\n * Set encryption configuration globally\n * \n * @param config - Partial encryption config to merge with current config\n * \n * @example\n * ```typescript\n * import { setEncryptionConfig } from '@scripturecoder/rn-alpha-hooks';\n * \n * setEncryptionConfig({\n *   key: process.env.ENCRYPTION_KEY,\n *   iv: process.env.ENCRYPTION_IV\n * });\n * ```\n */\nexport function setEncryptionConfig(config: Partial<EncryptionConfig>): void {\n  if (config.key !== undefined || config.iv !== undefined) {\n    currentConfig = { ...currentConfig, ...config };\n    hasWarnedAboutDefaultKeys = false; // Reset warning flag when keys are updated\n  }\n}\n\n/**\n * Get current encryption configuration\n * \n * @returns Current encryption config\n */\nexport function getEncryptionConfig(): EncryptionConfig {\n  return { ...currentConfig };\n}\n\n/**\n * Validate encryption config\n * \n * @param config - Encryption config to validate\n * @returns True if valid, false otherwise\n */\nexport function isValidEncryptionConfig(config: Partial<EncryptionConfig>): boolean {\n  if (!config.key || !config.iv) {\n    console.error('[rn-alpha-hooks] Encryption config must have both key and iv');\n    return false;\n  }\n  \n  if (config.key.length !== 16) {\n    console.error('[rn-alpha-hooks] Encryption key must be exactly 16 characters for AES-128');\n    return false;\n  }\n  \n  if (config.iv.length !== 16) {\n    console.error('[rn-alpha-hooks] IV (Initialization Vector) must be exactly 16 characters');\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Generate random encryption config (for development/testing)\n * âš ï¸ Store these securely - do not hardcode in your app!\n * \n * @returns New random encryption config\n * \n * @example\n * ```typescript\n * const config = generateEncryptionConfig();\n * console.log('Store these securely:');\n * console.log('Key:', config.key);\n * console.log('IV:', config.iv);\n * ```\n */\nexport function generateEncryptionConfig(): EncryptionConfig {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+';\n  \n  const generateRandomString = (length: number): string => {\n    let result = '';\n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  };\n  \n  return {\n    key: generateRandomString(16),\n    iv: generateRandomString(16),\n  };\n}\n\n/**\n * Encrypt a string using AES encryption\n * \n * @param payload - String to encrypt\n * @param customKey - Optional custom encryption key (overrides global config)\n * @param customIv - Optional custom IV (overrides global config)\n * @returns Encrypted string\n * \n * @example\n * ```typescript\n * // Using global config\n * const encrypted = encrypt('sensitive data');\n * \n * // Using custom keys for this operation\n * const encrypted = encrypt('data', 'my-custom-key123', 'my-custom-iv-123');\n * ```\n */\nexport function encrypt(\n  payload: string,\n  customKey?: string,\n  customIv?: string\n): string {\n  const keyStr = customKey || currentConfig.key;\n  const ivStr = customIv || currentConfig.iv;\n  \n  // Warn in development if using default keys\n  if (\n    typeof __DEV__ !== 'undefined' && \n    __DEV__ && \n    keyStr === DEFAULT_CONFIG.key && \n    !hasWarnedAboutDefaultKeys\n  ) {\n    console.warn(\n      '[rn-alpha-hooks] âš ï¸ Using default encryption keys! ' +\n      'Set custom keys via AlphaProvider config.encryption or setEncryptionConfig() for production.'\n    );\n    hasWarnedAboutDefaultKeys = true;\n  }\n  \n  const key = CryptoJS.enc.Utf8.parse(keyStr);\n  const iv = CryptoJS.enc.Utf8.parse(ivStr);\n  \n  return CryptoJS.AES.encrypt(payload, key, {\n    iv: iv,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  }).toString();\n}\n\n/**\n * Decrypt an encrypted string using AES decryption\n * \n * @param response - Encrypted string to decrypt\n * @param customKey - Optional custom encryption key (must match encryption key)\n * @param customIv - Optional custom IV (must match encryption IV)\n * @returns Decrypted string\n * \n * @example\n * ```typescript\n * // Using global config\n * const decrypted = decrypt(encryptedData);\n * \n * // Using custom keys (must match encryption keys)\n * const decrypted = decrypt(encryptedData, 'my-custom-key123', 'my-custom-iv-123');\n * ```\n */\nexport function decrypt(\n  response: string,\n  customKey?: string,\n  customIv?: string\n): string {\n  const keyStr = customKey || currentConfig.key;\n  const ivStr = customIv || currentConfig.iv;\n  \n  const key = CryptoJS.enc.Utf8.parse(keyStr);\n  const iv = CryptoJS.enc.Utf8.parse(ivStr);\n  \n  const decrypted_response = CryptoJS.AES.decrypt(\n    { ciphertext: CryptoJS.enc.Base64.parse(response) },\n    key,\n    { iv: iv }\n  );\n  \n  return decrypted_response.toString(CryptoJS.enc.Utf8);\n}\n","import { encrypt, decrypt, isValidEncryptionConfig, getEncryptionConfig } from \"../../utils/crypto\";\n\n/**\n * Encryption options for requests and responses\n */\nexport interface EncryptionOptions {\n  enabled?: boolean;\n  request?: 'full' | string[]; // Encrypt entire body or specific keys\n  response?: 'full' | string[]; // Decrypt entire response or specific keys\n}\n\n/**\n * Resolves encryption options from hook option and global config\n * @param hookOption - Encryption option passed to the hook\n * @param globalDefault - Global default from AlphaConfig\n * @returns Resolved EncryptionOptions or null if disabled\n */\nexport function resolveEncryptionOptions(\n  hookOption?: boolean | EncryptionOptions,\n  globalDefault?: boolean | EncryptionOptions\n): EncryptionOptions | null {\n  // Hook option takes precedence\n  if (hookOption !== undefined) {\n    if (hookOption === false) return null;\n    if (hookOption === true) return { enabled: true, request: 'full', response: 'full' };\n    return { enabled: true, ...hookOption };\n  }\n\n  // Fall back to global default\n  if (globalDefault !== undefined) {\n    if (globalDefault === false) return null;\n    if (globalDefault === true) return { enabled: true, request: 'full', response: 'full' };\n    return { enabled: true, ...globalDefault };\n  }\n\n  // Default: no encryption\n  return null;\n}\n\n/**\n * Applies encryption to request data based on options\n * @param data - Request data object\n * @param options - Encryption options\n * @returns Encrypted data object\n */\nexport function applyRequestEncryption(\n  data: Record<string, any>,\n  options: EncryptionOptions\n): Record<string, any> | string {\n  if (!options.enabled || !options.request) {\n    return data;\n  }\n\n  // Validate encryption config\n  const config = getEncryptionConfig();\n  if (!isValidEncryptionConfig(config)) {\n    throw new Error(\n      \"Encryption is enabled but encryption keys are not configured. \" +\n      \"Please set encryption keys via AlphaConfig or setEncryptionConfig().\"\n    );\n  }\n\n  try {\n    // Full body encryption\n    if (options.request === 'full') {\n      const jsonString = JSON.stringify(data);\n      const encrypted = encrypt(jsonString, config.key, config.iv);\n      return Object.keys(data).length > 0 ? encrypted : null;\n    }\n\n    // Partial encryption - specific keys\n    if (Array.isArray(options.request)) {\n      const result = { ...data };\n      for (const key of options.request) {\n        if (key in data) {\n          const value = data[key];\n          const valueString = typeof value === 'string' ? value : JSON.stringify(value);\n          result[key] = encrypt(valueString, config.key, config.iv);\n        }\n      }\n      return result;\n    }\n\n    return data;\n  } catch (error: any) {\n    throw new Error(`Request encryption failed: ${error.message}`);\n  }\n}\n\n/**\n * Applies decryption to response data based on options\n * @param data - Response data\n * @param options - Encryption options\n * @returns Decrypted data\n */\nexport function applyResponseDecryption(\n  data: any,\n  options: EncryptionOptions\n): any {\n  if (!options.enabled || !options.response) {\n    return data;\n  }\n\n  // Validate encryption config\n  const config = getEncryptionConfig();\n  if (!isValidEncryptionConfig(config)) {\n    throw new Error(\n      \"Decryption is enabled but encryption keys are not configured. \" +\n      \"Please set encryption keys via AlphaConfig or setEncryptionConfig().\"\n    );\n  }\n\n  try {\n    // Full response decryption\n    if (options.response === 'full') {\n      if (typeof data === 'string') {\n        const decrypted = decrypt(data, config.key, config.iv);\n        try {\n          return JSON.parse(decrypted);\n        } catch {\n          return decrypted;\n        }\n      }\n      // If data has an 'encrypted' field, decrypt that\n      if (data && typeof data === 'object' && 'encrypted' in data) {\n        const decrypted = decrypt(data.encrypted, config.key, config.iv);\n        try {\n          return JSON.parse(decrypted);\n        } catch {\n          return decrypted;\n        }\n      }\n      return data;\n    }\n\n    // Partial decryption - specific keys\n    if (Array.isArray(options.response) && data && typeof data === 'object') {\n      const result = { ...data };\n      for (const key of options.response) {\n        if (key in data && typeof data[key] === 'string') {\n          try {\n            const decrypted = decrypt(data[key], config.key, config.iv);\n            try {\n              result[key] = JSON.parse(decrypted);\n            } catch {\n              result[key] = decrypted;\n            }\n          } catch (error: any) {\n            // If decryption fails for a specific key, log warning but continue\n            console.warn(`Failed to decrypt key '${key}':`, error.message);\n          }\n        }\n      }\n      return result;\n    }\n\n    return data;\n  } catch (error: any) {\n    throw new Error(`Response decryption failed: ${error.message}`);\n  }\n}\n\n","import http, { Method } from \"../utils/service\";\nimport { useApp } from \"../store/contexts/app-context\";\nimport useDispatch from \"./use-dispatch\";\nimport { actions } from \"../store/reducers/cache-reducer\";\nimport * as network from \"../store/reducers/thread-reducer\";\nimport useCache from \"./use-cache\";\nimport { Route } from \"../types\";\nimport { MutationResponse } from \"./types\";\nimport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  isAbortError,\n  createErrorResponse,\n  createSuccessResponse,\n} from \"./utils/error-handler\";\nimport { extractResponseData } from \"./utils/response-helpers\";\nimport { useAlphaConfig } from \"../store/contexts/config-context\";\nimport {\n  resolveEncryptionOptions,\n  applyRequestEncryption,\n  applyResponseDecryption,\n  EncryptionOptions,\n} from \"./utils/encryption-helpers\";\n\n/**\n * Options for async query\n */\ninterface UseQueryAsyncOptions {\n  authToken?: string;\n  signal?: AbortSignal;\n  encrypted?: boolean | EncryptionOptions;\n  dataPath?: string; // Override global dataPath for this query\n}\n\n/**\n * Hook return type - a function that performs async queries\n */\ntype UseQueryAsyncReturn = (\n  route: Route,\n  variables?: Record<string, any>,\n  options?: UseQueryAsyncOptions | string // string for backward compatibility (authToken)\n) => Promise<MutationResponse>;\n\n/**\n * Custom hook for async data fetching without subscriptions\n * Useful for one-time data fetches that update the cache\n * @returns An async function to fetch data\n */\nconst useQueryAsync = (): UseQueryAsyncReturn => {\n  const app = useApp();\n  const { auth } = app;\n  const { getContext } = useCache();\n  const dispatch = useDispatch();\n  const [config] = useAlphaConfig();\n\n  /**\n   * Performs an async query and updates cache and loading state\n   * @param route - The API route key\n   * @param variables - Query variables\n   * @param options - Optional auth token or options object with signal\n   * @returns Promise with response data or error\n   */\n  return async (\n    route: Route,\n    variables: Record<string, any> = {},\n    options?: UseQueryAsyncOptions | string\n  ): Promise<MutationResponse> => {\n    const { key, method, path } = getContext(route, variables);\n\n    // Handle backward compatibility (authToken as string)\n    const opts: UseQueryAsyncOptions =\n      typeof options === 'string'\n        ? { authToken: options }\n        : options || {};\n\n    // Resolve encryption options\n    const encryptionOptions = resolveEncryptionOptions(opts.encrypted, config.defaultEncryption);\n\n    // Resolve dataPath (option > global config)\n    const resolvedDataPath = opts.dataPath !== undefined ? opts.dataPath : config.dataPath;\n\n    try {\n      // Set loading state\n      dispatch(\n        network.actions.set({\n          key,\n          value: {\n            loading: true,\n            error: undefined,\n          },\n        })\n      );\n\n      // Apply request encryption if enabled\n      const requestData = encryptionOptions\n        ? applyRequestEncryption(variables, encryptionOptions)\n        : variables;\n\n      // Perform the request\n      const res: any = await http(\n        path,\n        (method as Method) || \"GET\",\n        requestData,\n        {\n          returnStatus: true,\n          auth: opts.authToken || auth.accessToken,\n          signal: opts.signal,\n        }\n      );\n\n      const error = !isSuccessStatus(res.status)\n        ? extractErrorMessage(res)\n        : undefined;\n\n      // Update loading/error state\n      dispatch(\n        network.actions.set({\n          key,\n          value: {\n            loading: false,\n            error,\n          },\n        })\n      );\n\n      if (isSuccessStatus(res.status)) {\n\n        let responseData = res.data\n        // Apply response decryption if enabled\n        if (encryptionOptions && responseData) {\n          responseData = applyResponseDecryption(responseData, encryptionOptions);\n        }\n\n        responseData = extractResponseData(responseData, resolvedDataPath);\n\n        dispatch(actions.set({ key, value: responseData }));\n        return createSuccessResponse(responseData, res.status);\n      } else if (isAuthError(res.status)) {\n        // Handle auth errors - clear authentication\n        app.clearAuth();\n        return createErrorResponse(error || \"Unauthorized\", res.status);\n      }\n\n      return createErrorResponse(error || \"Request failed\", res.status);\n    } catch (e: any) {\n      // Handle abort errors differently - don't update state\n      if (isAbortError(e)) {\n        dispatch(\n          network.actions.set({\n            key,\n            value: {\n              loading: false,\n              error: undefined,\n            },\n          })\n        );\n        return createErrorResponse(\"Request cancelled\", 0);\n      }\n\n      const error = e.message || \"Oops! an error occurred\";\n\n      // Update error state\n      dispatch(\n        network.actions.set({\n          key,\n          value: {\n            loading: false,\n            error,\n          },\n        })\n      );\n\n      return createErrorResponse(error, 500);\n    }\n  };\n};\n\nexport default useQueryAsync;\n","import { useState, useCallback, useRef, useEffect } from \"react\";\nimport http, { Method } from \"../utils/service\";\nimport { useApp } from \"store/contexts/app-context\";\nimport { Keyboard } from \"react-native\";\nimport { Route } from \"types\";\nimport useCache from \"./use-cache\";\nimport { MutationOptions, MutationResult, MutationResponse } from \"./types\";\nimport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  isAbortError,\n  createErrorResponse,\n  createSuccessResponse,\n} from \"hooks/utils\";\nimport { ERROR_MESSAGES } from \"./constants\";\nimport { extractResponseData } from \"./utils/response-helpers\";\nimport { useAlphaConfig } from \"../store/contexts/config-context\";\nimport {\n  resolveEncryptionOptions,\n  applyRequestEncryption,\n  applyResponseDecryption,\n} from \"./utils/encryption-helpers\";\n\n/**\n * Custom hook for data mutations (POST, PUT, DELETE operations)\n * @param route - The API route key\n * @param option - Mutation options (keyboard dismiss, text response)\n * @returns MutationResult with mutate function, loading state, error, and data\n */\nconst useMutation = <T = any,>(\n  route: Route,\n  option?: MutationOptions\n): MutationResult<T> => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | undefined>(undefined);\n  const [data, setData] = useState<T | undefined>(undefined);\n  const [status, setStatus] = useState<number | undefined>(undefined);\n\n  const app = useApp();\n  const { auth } = app;\n  const { getContext } = useCache();\n  const [config] = useAlphaConfig();\n\n  // Resolve encryption options (hook option > global config)\n  const encryptionOptions = resolveEncryptionOptions(option?.encrypted, config.defaultEncryption);\n\n  // Resolve dataPath (hook option > global config)\n  const resolvedDataPath = option?.dataPath !== undefined ? option.dataPath : config.dataPath;\n\n  // Store abort controller for request cancellation\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  /**\n   * Performs the mutation request\n   * @param variables - Request variables\n   * @returns Promise with response data or error\n   */\n  const mutate = useCallback(\n    async (variables: Record<string, any>): Promise<MutationResponse<T>> => {\n      try {\n        // Dismiss keyboard by default\n        if (option?.keyboard === undefined || option?.keyboard) {\n          Keyboard.dismiss();\n        }\n\n        const { path, method, rawPath } = getContext(route, variables);\n\n        // Abort any existing request\n        if (abortControllerRef.current) {\n          abortControllerRef.current.abort();\n        }\n\n        // Create new abort controller\n        abortControllerRef.current = new AbortController();\n\n        setLoading(true);\n        setError(undefined);\n        setStatus(undefined);\n\n        // Apply request encryption if enabled\n        const requestData = encryptionOptions\n          ? applyRequestEncryption(variables, encryptionOptions)\n          : variables;\n\n        const res: any = await http(\n          path,\n          (method as Method) || \"POST\",\n          requestData,\n          {\n            returnStatus: true,\n            auth: auth?.accessToken,\n            returnText: option?.text,\n            signal: abortControllerRef.current.signal,\n          }\n        );\n\n        if (isSuccessStatus(res.status)) {\n          let responseData = res.data\n          // Apply response decryption if enabled\n          if (encryptionOptions && responseData) {\n            responseData = applyResponseDecryption(responseData, encryptionOptions);\n          }\n          responseData = extractResponseData(responseData, resolvedDataPath);\n\n          setData(responseData);\n          setStatus(res.status);\n          setLoading(false);\n          return createSuccessResponse(responseData, res.status);\n        }\n\n        let errorMessage = extractErrorMessage(res);\n\n        // Check for auth errors\n        if (rawPath.includes(\":customerId\") && isAuthError(res.status)) {\n          errorMessage = ERROR_MESSAGES.SESSION_EXPIRED;\n          // Auth error - clear authentication\n          app.clearAuth();\n        }\n\n        setError(errorMessage);\n        setStatus(res.status);\n        setLoading(false);\n        return createErrorResponse(errorMessage, res.status);\n      } catch (e: any) {\n        // Handle abort errors - don't set error state for cancellations\n        if (isAbortError(e)) {\n          setLoading(false);\n          setStatus(0);\n          return createErrorResponse(\"Request cancelled\", 0);\n        }\n\n        setLoading(false);\n        const errorMessage = e.message || ERROR_MESSAGES.GENERIC;\n        setError(errorMessage);\n        setStatus(500);\n        return createErrorResponse(errorMessage, 500);\n      }\n    },\n    [route, option, auth, app, getContext, encryptionOptions, resolvedDataPath]\n  );\n\n  /**\n   * Cancels the current mutation request\n   */\n  const cancel = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  return [\n    mutate,\n    {\n      loading,\n      error,\n      data,\n      status,\n      cancel,\n    }\n  ];\n};\n\nexport default useMutation;\n","import { useState, useCallback, useRef, useEffect } from \"react\";\nimport http from \"../utils/service\";\nimport { useApp } from \"../store/contexts/app-context\";\nimport { Keyboard } from \"react-native\";\nimport { Route } from \"../types\";\nimport useCache from \"./use-cache\";\nimport { MutationOptions, MutationResult, MutationResponse } from \"./types\";\nimport {\n  extractErrorMessage,\n  isSuccessStatus,\n  isAuthError,\n  isAbortError,\n  createErrorResponse,\n  createSuccessResponse,\n} from \"./utils/error-handler\";\nimport { ERROR_MESSAGES } from \"./constants\";\nimport { extractResponseData } from \"./utils/response-helpers\";\nimport { useAlphaConfig } from \"../store/contexts/config-context\";\nimport {\n  resolveEncryptionOptions,\n  applyRequestEncryption,\n  applyResponseDecryption,\n} from \"./utils/encryption-helpers\";\n\n/**\n * Custom hook for async mutations with extended functionality\n * Unlike useMutation, this version uses route string directly (legacy support)\n * @param route - The raw API route string (e.g., \"POST:/endpoint/:param\")\n * @param option - Mutation options (keyboard dismiss)\n * @returns MutationResult with mutate function, loading state, error, and data\n */\nconst useMutationAsync = <T = any,>(\n  route: string,\n  option?: MutationOptions\n): MutationResult<T> => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | undefined>(undefined);\n  const [data, setData] = useState<T | undefined>(undefined);\n  const [status, setStatus] = useState<number | undefined>(undefined);\n  \n  const app = useApp();\n  const { auth } = app;\n  const [config] = useAlphaConfig();\n  \n  // Resolve encryption options (hook option > global config)\n  const encryptionOptions = resolveEncryptionOptions(option?.encrypted, config.defaultEncryption);\n  \n  // Resolve dataPath (hook option > global config)\n  const resolvedDataPath = option?.dataPath !== undefined ? option.dataPath : config.dataPath;\n  \n  // Store abort controller for request cancellation\n  const abortControllerRef = useRef<AbortController | null>(null);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  /**\n   * Performs the mutation request\n   * @param variables - Request variables\n   * @returns Promise with response data or error\n   */\n  const mutate = useCallback(\n    async (variables: Record<string, any>): Promise<MutationResponse<T>> => {\n      try {\n        // Dismiss keyboard by default\n        if (option?.keyboard === undefined || option?.keyboard) {\n          Keyboard.dismiss();\n        }\n\n        // Parse route manually (legacy format support)\n        const [method, pathTemplate] = route.split(\":/\");\n        const variablesCopy = { ...variables };\n        \n        const path = \"/\" + pathTemplate.replace(/:\\w+/g, (matched: string) => {\n          const paramName = matched.replace(/\\W/g, \"\");\n          const value = variablesCopy[paramName];\n          delete variablesCopy[paramName];\n          return value || matched;\n        });\n\n        // Abort any existing request\n        if (abortControllerRef.current) {\n          abortControllerRef.current.abort();\n        }\n        \n        // Create new abort controller\n        abortControllerRef.current = new AbortController();\n        \n        setLoading(true);\n        setError(undefined);\n        setStatus(undefined);\n\n        // Apply request encryption if enabled\n        const requestData = encryptionOptions\n          ? applyRequestEncryption(variablesCopy, encryptionOptions)\n          : variablesCopy;\n\n        const res: any = await http(\n          path,\n          (method as any) || \"POST\",\n          requestData,\n          {\n            returnStatus: true,\n            auth: auth.accessToken,\n            signal: abortControllerRef.current.signal,\n          }\n        );\n\n        if (isSuccessStatus(res.status)) {\n          let responseData = extractResponseData(res.data, resolvedDataPath);\n          \n          // Apply response decryption if enabled\n          if (encryptionOptions && responseData) {\n            responseData = applyResponseDecryption(responseData, encryptionOptions);\n          }\n          \n          setData(responseData);\n          setStatus(res.status);\n          setLoading(false);\n          return createSuccessResponse(responseData, res.status);\n        }\n\n        // Check for auth errors (avoid login route check)\n        if (isAuthError(res.status)) {\n          // Auth error - clear authentication\n          app.clearAuth();\n        }\n\n        const errorMessage = extractErrorMessage(res);\n        setError(errorMessage);\n        setStatus(res.status);\n        setLoading(false);\n        return createErrorResponse(errorMessage, res.status);\n      } catch (e: any) {\n        // Handle abort errors - don't set error state for cancellations\n        if (isAbortError(e)) {\n          setLoading(false);\n          setStatus(0);\n          return createErrorResponse(\"Request cancelled\", 0);\n        }\n        \n        setLoading(false);\n        const errorMessage = e.message || ERROR_MESSAGES.GENERIC;\n        setError(errorMessage);\n        setStatus(500);\n        return createErrorResponse(errorMessage, 500);\n      }\n    },\n    [route, option, auth, app, encryptionOptions, resolvedDataPath]\n  );\n  \n  /**\n   * Cancels the current mutation request\n   */\n  const cancel = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  return [\n    mutate,\n    {\n      loading,\n      error,\n      data,\n      status,\n      cancel,\n    }\n  ];\n};\n\nexport default useMutationAsync;\n","/**\n * HTTP Helper Utilities\n * Provides utilities for managing AbortControllers, checking error types,\n * and formatting request data\n */\n\n/**\n * Creates a new AbortController for request cancellation\n * @returns New AbortController instance\n * \n * @example\n * const controller = createAbortController();\n * http('/api/data', 'GET', {}, { signal: controller.signal });\n * // Later: controller.abort();\n */\nexport const createAbortController = (): AbortController => {\n  return new AbortController();\n};\n\n/**\n * Checks if an error is an abort/cancellation error\n * @param error - The error to check\n * @returns True if the error is from request cancellation\n * \n * @example\n * try {\n *   await http('/api/data', 'GET', {}, { signal: controller.signal });\n * } catch (error) {\n *   if (isAbortError(error)) {\n *     console.log('Request was cancelled');\n *   }\n * }\n */\nexport const isAbortError = (error: any): boolean => {\n  if (!error) return false;\n  \n  return (\n    error.name === 'AbortError' ||\n    error.name === 'CanceledError' ||\n    error.code === 'ERR_CANCELED' ||\n    error.message?.includes('abort') ||\n    error.message?.includes('cancel')\n  );\n};\n\n/**\n * Checks if an error is a cancellation error (alias for isAbortError)\n * @param error - The error to check\n * @returns True if the error is from request cancellation\n */\nexport const isCancelError = (error: any): boolean => {\n  return isAbortError(error);\n};\n\n/**\n * Determines if a request should be retried based on the error\n * @param error - The error to check\n * @returns True if the request should be retried\n * \n * @example\n * try {\n *   await http('/api/data', 'GET', {});\n * } catch (error) {\n *   if (shouldRetry(error)) {\n *     // Retry the request\n *   }\n * }\n */\nexport const shouldRetry = (error: any): boolean => {\n  // Don't retry if it was cancelled\n  if (isAbortError(error)) {\n    return false;\n  }\n\n  // Don't retry client errors (4xx)\n  if (error.response?.status >= 400 && error.response?.status < 500) {\n    return false;\n  }\n\n  // Retry on network errors or 5xx server errors\n  return true;\n};\n\n/**\n * Converts an object to FormData for multipart/form-data requests\n * @param data - Object to convert\n * @returns FormData instance\n * \n * @example\n * const formData = formatFormData({ name: 'John', age: 30 });\n * http('/api/upload', 'POST', formData, { contentType: 'multipart' });\n */\nexport const formatFormData = (data: Record<string, any>): FormData => {\n  const formData = new FormData();\n  \n  for (const key in data) {\n    if (data.hasOwnProperty(key)) {\n      const value = data[key];\n      \n      // Handle different types appropriately\n      if (value !== null && value !== undefined) {\n        formData.append(key, value);\n      }\n    }\n  }\n  \n  return formData;\n};\n\n/**\n * Converts an object to URL-encoded string for application/x-www-form-urlencoded requests\n * @param data - Object to convert\n * @returns URL-encoded string\n * \n * @example\n * const encoded = formatUrlEncoded({ name: 'John Doe', age: 30 });\n * // Returns: \"name=John%20Doe&age=30\"\n */\nexport const formatUrlEncoded = (data: Record<string, any>): string => {\n  const formBody: string[] = [];\n  \n  for (const property in data) {\n    if (data.hasOwnProperty(property)) {\n      const value = data[property];\n      \n      // Skip null/undefined values\n      if (value !== null && value !== undefined) {\n        const encodedKey = encodeURIComponent(property);\n        const encodedValue = encodeURIComponent(value);\n        formBody.push(`${encodedKey}=${encodedValue}`);\n      }\n    }\n  }\n  \n  return formBody.join('&');\n};\n\n/**\n * Safely aborts an AbortController if it exists\n * @param controller - The AbortController to abort\n * \n * @example\n * const controller = createAbortController();\n * // Later...\n * safeAbort(controller);\n */\nexport const safeAbort = (controller: AbortController | null | undefined): void => {\n  if (controller && !controller.signal.aborted) {\n    controller.abort();\n  }\n};\n\n/**\n * Creates a timeout-based AbortController\n * @param timeoutMs - Timeout in milliseconds\n * @returns Object with controller and cleanup function\n * \n * @example\n * const { controller, cleanup } = createTimeoutController(5000);\n * try {\n *   await http('/api/data', 'GET', {}, { signal: controller.signal });\n * } finally {\n *   cleanup();\n * }\n */\nexport const createTimeoutController = (\n  timeoutMs: number\n): { controller: AbortController; cleanup: () => void } => {\n  const controller = new AbortController();\n  \n  const timeoutId = setTimeout(() => {\n    controller.abort();\n  }, timeoutMs);\n  \n  const cleanup = () => {\n    clearTimeout(timeoutId);\n  };\n  \n  return { controller, cleanup };\n};\n\n/**\n * Combines multiple AbortSignals into one\n * When any signal is aborted, the combined signal is aborted\n * @param signals - Array of AbortSignals to combine\n * @returns Combined AbortController\n * \n * @example\n * const userController = createAbortController();\n * const timeoutController = createTimeoutController(5000);\n * const combined = combineAbortSignals([userController.signal, timeoutController.signal]);\n * await http('/api/data', 'GET', {}, { signal: combined.signal });\n */\nexport const combineAbortSignals = (signals: AbortSignal[]): AbortController => {\n  const controller = new AbortController();\n  \n  for (const signal of signals) {\n    if (signal.aborted) {\n      controller.abort();\n      break;\n    }\n    \n    signal.addEventListener('abort', () => {\n      controller.abort();\n    }, { once: true });\n  }\n  \n  return controller;\n};\n\n","/**\n * Retry Manager with Exponential Backoff\n * Provides intelligent retry logic for failed requests\n */\n\nimport { shouldRetry as shouldRetryError } from \"./error-handler\";\n\nexport interface RetryOptions {\n  retries: number;\n  delay: number | 'exponential';\n  condition?: (error: any) => boolean;\n  maxDelay?: number;\n}\n\n/**\n * Retries a function with exponential backoff\n * @param fn - The function to retry\n * @param options - Retry configuration\n * @returns Promise that resolves when function succeeds or retries are exhausted\n * \n * @example\n * const data = await retryWithBackoff(\n *   () => http('/api/data', 'GET'),\n *   { retries: 3, delay: 'exponential' }\n * );\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions\n): Promise<T> {\n  const { retries, delay, condition, maxDelay = 30000 } = options;\n  let lastError: any;\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      // Check custom condition if provided\n      if (condition && !condition(error)) {\n        throw error;\n      }\n\n      // Check if error is retryable\n      if (!shouldRetryError(error)) {\n        throw error;\n      }\n\n      // Don't wait after last attempt\n      if (attempt === retries) {\n        throw error;\n      }\n\n      // Calculate delay\n      const waitTime = calculateDelay(delay, attempt, maxDelay);\n\n      // Wait before next attempt\n      await sleep(waitTime);\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Calculate delay based on strategy\n */\nfunction calculateDelay(\n  delay: number | 'exponential',\n  attempt: number,\n  maxDelay: number\n): number {\n  if (delay === 'exponential') {\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (capped)\n    return Math.min(1000 * Math.pow(2, attempt), maxDelay);\n  }\n  return delay;\n}\n\n/**\n * Sleep utility\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Retry with jitter (adds randomness to prevent thundering herd)\n */\nexport async function retryWithJitter<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions & { jitter?: number }\n): Promise<T> {\n  const { jitter = 0.1, ...retryOptions } = options;\n\n  return retryWithBackoff(fn, {\n    ...retryOptions,\n    delay:\n      typeof retryOptions.delay === 'number'\n        ? addJitter(retryOptions.delay, jitter)\n        : retryOptions.delay,\n  });\n}\n\n/**\n * Adds random jitter to delay\n */\nfunction addJitter(delay: number, jitterFactor: number): number {\n  const jitter = delay * jitterFactor * Math.random();\n  return delay + jitter;\n}\n\n","/**\n * Offline Queue for Mutations\n * Queues mutations when offline and replays them when connection is restored\n */\n\nimport uuid from 'react-native-uuid';\nimport { Route } from '../../types';\n\n// Import MMKV storage (has set, getString methods)\nlet storage: any;\ntry {\n  storage = require('../../utils/storage').default;\n} catch (e) {\n  // Fallback if storage not available\n  storage = {\n    set: () => {},\n    getString: () => undefined,\n  };\n}\n\nexport interface QueuedMutation {\n  id: string;\n  route: Route;\n  variables: Record<string, any>;\n  timestamp: number;\n  retries: number;\n  maxRetries: number;\n}\n\nconst STORAGE_KEY = 'offline_mutation_queue';\nconst DEFAULT_MAX_RETRIES = 3;\n\n/**\n * Offline Mutation Queue\n * Persists mutations to local storage and processes them when online\n */\nexport class OfflineQueue {\n  private queue: QueuedMutation[] = [];\n  private isProcessing = false;\n\n  constructor() {\n    this.loadFromStorage();\n  }\n\n  /**\n   * Adds a mutation to the queue\n   */\n  async enqueue(\n    mutation: Omit<QueuedMutation, 'id' | 'timestamp' | 'retries' | 'maxRetries'>\n  ): Promise<string> {\n    const item: QueuedMutation = {\n      ...mutation,\n      id: uuid.v4() as string,\n      timestamp: Date.now(),\n      retries: 0,\n      maxRetries: DEFAULT_MAX_RETRIES,\n    };\n\n    this.queue.push(item);\n    await this.persist();\n\n    return item.id;\n  }\n\n  /**\n   * Processes the queue\n   */\n  async processQueue(\n    onProcess: (item: QueuedMutation) => Promise<void>\n  ): Promise<void> {\n    if (this.isProcessing || this.queue.length === 0) {\n      return;\n    }\n\n    this.isProcessing = true;\n\n    while (this.queue.length > 0) {\n      const item = this.queue[0];\n\n      try {\n        await onProcess(item);\n        // Success - remove from queue\n        this.queue.shift();\n        await this.persist();\n      } catch (error) {\n        // Failure - increment retries\n        item.retries++;\n\n        if (item.retries >= item.maxRetries) {\n          // Give up on this item\n          console.warn(`[OfflineQueue] Giving up on mutation ${item.id} after ${item.retries} retries`);\n          this.queue.shift();\n          await this.persist();\n        } else {\n          // Stop processing, will retry later\n          break;\n        }\n      }\n    }\n\n    this.isProcessing = false;\n  }\n\n  /**\n   * Gets the current queue\n   */\n  getQueue(): ReadonlyArray<QueuedMutation> {\n    return [...this.queue];\n  }\n\n  /**\n   * Gets the queue size\n   */\n  size(): number {\n    return this.queue.length;\n  }\n\n  /**\n   * Clears the entire queue\n   */\n  async clear(): Promise<void> {\n    this.queue = [];\n    await this.persist();\n  }\n\n  /**\n   * Removes a specific mutation from the queue\n   */\n  async remove(id: string): Promise<boolean> {\n    const index = this.queue.findIndex((item) => item.id === id);\n    if (index > -1) {\n      this.queue.splice(index, 1);\n      await this.persist();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Persists queue to storage\n   */\n  private async persist(): Promise<void> {\n    try {\n      storage.set(STORAGE_KEY, JSON.stringify(this.queue));\n    } catch (error) {\n      console.error('[OfflineQueue] Failed to persist queue:', error);\n    }\n  }\n\n  /**\n   * Loads queue from storage\n   */\n  private loadFromStorage(): void {\n    try {\n      const stored = storage.getString(STORAGE_KEY);\n      if (stored) {\n        this.queue = JSON.parse(stored);\n      }\n    } catch (error) {\n      console.error('[OfflineQueue] Failed to load queue:', error);\n      this.queue = [];\n    }\n  }\n}\n\n// Singleton instance\nlet queueInstance: OfflineQueue | null = null;\n\n/**\n * Gets the singleton queue instance\n */\nexport function getOfflineQueue(): OfflineQueue {\n  if (!queueInstance) {\n    queueInstance = new OfflineQueue();\n  }\n  return queueInstance;\n}\n\n","/**\n * Refetch Manager\n * Handles background refetching on focus, reconnect, and intervals\n */\n\nimport { useEffect, useRef } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\nimport { useSocket } from '../../store/contexts/socket-context';\n\n/**\n * Refetches when app comes to foreground\n * @param enabled - Whether this behavior is enabled\n * @param refetch - Function to call for refetching\n */\nexport function useRefetchOnFocus(\n  enabled: boolean,\n  refetch: () => void\n): void {\n  const appState = useRef(AppState.currentState);\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    const subscription = AppState.addEventListener('change', (nextAppState: AppStateStatus) => {\n      // App has come to the foreground\n      if (\n        appState.current.match(/inactive|background/) &&\n        nextAppState === 'active'\n      ) {\n        refetch();\n      }\n\n      appState.current = nextAppState;\n    });\n\n    return () => {\n      subscription.remove();\n    };\n  }, [enabled, refetch]);\n}\n\n/**\n * Refetches when network reconnects\n * @param enabled - Whether this behavior is enabled\n * @param refetch - Function to call for refetching\n */\nexport function useRefetchOnReconnect(\n  enabled: boolean,\n  refetch: () => void\n): void {\n  const { connected } = useSocket();\n  const prevConnected = useRef(connected);\n\n  useEffect(() => {\n    if (enabled && connected && !prevConnected.current) {\n      // Just reconnected\n      refetch();\n    }\n    prevConnected.current = connected;\n  }, [connected, enabled, refetch]);\n}\n\n/**\n * Refetches at a regular interval\n * @param enabled - Whether polling is enabled\n * @param refetch - Function to call for refetching\n * @param interval - Interval in milliseconds\n */\nexport function useRefetchInterval(\n  enabled: boolean,\n  refetch: () => void,\n  interval: number\n): void {\n  useEffect(() => {\n    if (!enabled || interval <= 0) return;\n\n    const timer = setInterval(() => {\n      refetch();\n    }, interval);\n\n    return () => {\n      clearInterval(timer);\n    };\n  }, [enabled, refetch, interval]);\n}\n\n","import React, { ReactNode, useMemo, useEffect } from 'react';\nimport { Provider } from 'react-redux';\nimport { Store } from '@reduxjs/toolkit';\nimport AppProvider from './app-context';\nimport ConfigProvider from './config-context';\nimport { AlphaConfig } from '../../config';\nimport { createAlphaStore, CustomReducers, StoreOptions, defaultStore } from '../create-store';\nimport { setHttpConfig } from '../../utils/service';\nimport { setMaxCacheSize } from '../reducers/cache-reducer';\nimport { setEncryptionConfig } from '../../utils/crypto';\n\ninterface AlphaProviderProps {\n  children: ReactNode;\n  config: AlphaConfig;\n  /** Custom reducers to add to the store (e.g., theme, settings) */\n  customReducers?: CustomReducers;\n  /** Provide a completely custom store (overrides customReducers) */\n  store?: Store;\n  /** Store configuration options */\n  storeOptions?: StoreOptions;\n}\n\n/**\n * Root provider for rn-alpha package\n * Wraps your app with Redux, Config, and App contexts\n * Now supports custom reducers and store configuration\n * \n * @example\n * // Basic usage\n * ```typescript\n * <AlphaProvider config={{\n *   baseUrl: 'https://api.example.com',\n *   paths: { login: 'POST:/auth/login' },\n *   debug: __DEV__,\n * }}>\n *   <App />\n * </AlphaProvider>\n * ```\n * \n * @example\n * // With custom reducers\n * ```typescript\n * const settingsSlice = createSlice({\n *   name: 'settings',\n *   initialState: { theme: 'light' },\n *   reducers: { setTheme: (state, action) => { state.theme = action.payload; } }\n * });\n * \n * <AlphaProvider \n *   config={{ baseUrl: 'https://api.example.com' }}\n *   customReducers={{ settings: settingsSlice.reducer }}\n * >\n *   <App />\n * </AlphaProvider>\n * ```\n * \n * @example\n * // With store options\n * ```typescript\n * <AlphaProvider \n *   config={{ baseUrl: 'https://api.example.com' }}\n *   storeOptions={{ persist: true, storageKey: 'my-app-state' }}\n * >\n *   <App />\n * </AlphaProvider>\n * ```\n */\nexport const AlphaProvider: React.FC<AlphaProviderProps> = ({ \n  children, \n  config,\n  customReducers,\n  store: customStore,\n  storeOptions,\n}) => {\n  // Create store with custom reducers or use provided store\n  const store = useMemo(() => {\n    if (customStore) return customStore;\n    if (customReducers) return createAlphaStore(customReducers, storeOptions);\n    return defaultStore;\n  }, [customStore, customReducers, storeOptions]);\n\n  // Initialize HTTP client, cache settings, and encryption config\n  useEffect(() => {\n    setHttpConfig(config);\n    \n    if (config.cache?.maxSize) {\n      setMaxCacheSize(config.cache.maxSize);\n    }\n    \n    // Initialize encryption config if provided\n    if (config.encryption) {\n      setEncryptionConfig(config.encryption);\n    }\n  }, [config]);\n\n  return (\n    <Provider store={store}>\n      <ConfigProvider config={config}>\n        <AppProvider>\n          {children}\n        </AppProvider>\n      </ConfigProvider>\n    </Provider>\n  );\n};\n\nexport default AlphaProvider;\n\n","import { configureStore, combineReducers, Reducer } from '@reduxjs/toolkit';\nimport AlphaStorage from '../utils/storage';\nimport cacheReducer from './reducers/cache-reducer';\nimport threadReducer from './reducers/thread-reducer';\nimport appReducer from './reducers/app-reducer';\n\n/**\n * Custom reducers that apps can provide\n */\nexport interface CustomReducers {\n  [key: string]: Reducer<any>;\n}\n\n/**\n * Store configuration options\n */\nexport interface StoreOptions {\n  /** Enable state persistence to local storage */\n  persist?: boolean;\n  /** Custom storage key for persistence */\n  storageKey?: string;\n}\n\n/**\n * Save state to local storage\n */\nconst saveToLocalStorage = (state: any, key: string) => {\n  try {\n    AlphaStorage.setItem(key, state);\n  } catch (e) {\n    console.error('[AlphaStore] Failed to save state:', e);\n  }\n};\n\n/**\n * Load state from local storage\n */\nconst loadFromLocalStorage = (key: string) => {\n  try {\n    const serializedState = AlphaStorage.getItem(key);\n    if (serializedState === null) return undefined;\n    return serializedState;\n  } catch (e) {\n    console.warn('[AlphaStore] Failed to load state:', e);\n    return undefined;\n  }\n};\n\n/**\n * Creates a Redux store with core reducers + custom app reducers\n * @param customReducers - Additional reducers for app-specific state\n * @param options - Store configuration options\n * \n * @example\n * // Basic usage\n * const store = createAlphaStore();\n * \n * @example\n * // With custom reducers\n * const store = createAlphaStore({\n *   settings: settingsReducer,\n *   theme: themeReducer,\n * });\n * \n * @example\n * // With persistence\n * const store = createAlphaStore(customReducers, { \n *   persist: true,\n *   storageKey: 'my-app-state'\n * });\n */\nexport function createAlphaStore<T extends CustomReducers = {}>(\n  customReducers?: T,\n  options: StoreOptions = {}\n) {\n  const {\n    persist = true,\n    storageKey = '_alpha_state',\n  } = options;\n\n  // Combine core and custom reducers\n  const rootReducer = combineReducers({\n    // Core reducers (always included)\n    cache: cacheReducer,\n    thread: threadReducer,\n    app: appReducer,\n    // Custom app reducers\n    ...customReducers,\n  });\n\n  // Load persisted state if enabled\n  const preloadedState = persist \n    ? loadFromLocalStorage(storageKey) as Partial<ReturnType<typeof rootReducer>>\n    : undefined;\n\n  // Create store\n  const store = configureStore({\n    reducer: rootReducer as any, // Type assertion needed for dynamic reducer combination\n    preloadedState,\n    middleware: (getDefaultMiddleware) =>\n      getDefaultMiddleware({\n        immutableCheck: false,\n        serializableCheck: false, // Allow non-serializable values\n      }),\n  });\n\n  // Subscribe to state changes for persistence\n  if (persist) {\n    store.subscribe(() => {\n      saveToLocalStorage(store.getState(), storageKey);\n    });\n  }\n\n  return store;\n}\n\n// Default store (backward compatibility)\nexport const defaultStore = createAlphaStore();\n\n// Types\nexport type RootState<T extends CustomReducers = {}> = ReturnType<\n  ReturnType<typeof createAlphaStore<T>>['getState']\n>;\n\nexport type AppDispatch = ReturnType<typeof createAlphaStore>['dispatch'];\n\n","/**\n * TypeScript helper utilities for creating type-safe custom stores\n * \n * These utilities make it easier to work with custom reducers and extended state\n * while maintaining full type safety throughout your application.\n */\n\nimport { TypedUseSelectorHook, useSelector as useReduxSelector, useDispatch as useReduxDispatch } from 'react-redux';\nimport { AppDispatch, RootState } from './create-store';\n\n/**\n * Creates a typed selector hook for your app's complete state\n * \n * @example\n * ```typescript\n * // Define your app state\n * interface MyAppState {\n *   settings: SettingsState;\n *   preferences: PreferencesState;\n * }\n * \n * // Create typed selector\n * export const useTypedSelector = createTypedSelector<MyAppState>();\n * \n * // Use in components\n * const theme = useTypedSelector((state) => state.settings.theme); // fully typed!\n * ```\n */\nexport function createTypedSelector<TState extends Record<string, any>>(): TypedUseSelectorHook<TState> {\n  return useReduxSelector as TypedUseSelectorHook<TState>;\n}\n\n/**\n * Creates a typed dispatch hook for your app\n * \n * @example\n * ```typescript\n * export const useAppDispatch = createTypedDispatch();\n * \n * // Use in components\n * const dispatch = useAppDispatch();\n * dispatch(myAction()); // typed based on your reducers\n * ```\n */\nexport function createTypedDispatch() {\n  return useReduxDispatch<AppDispatch>;\n}\n\n/**\n * Helper type to infer action types from a slice\n * \n * @example\n * ```typescript\n * const settingsSlice = createSlice({ ... });\n * type SettingsActions = InferActions<typeof settingsSlice.actions>;\n * ```\n */\nexport type InferActions<T extends Record<string, (...args: any[]) => any>> = ReturnType<T[keyof T]>;\n\n/**\n * Helper type to merge core state with custom state\n * \n * @example\n * ```typescript\n * import { RootState } from '@scripturecoder/rn-alpha';\n * \n * interface CustomSlices {\n *   settings: SettingsState;\n *   preferences: PreferencesState;\n * }\n * \n * type AppState = ExtendedRootState<CustomSlices>;\n * // Now AppState includes: app, cache, thread, settings, preferences\n * ```\n */\nexport type ExtendedRootState<TCustom extends Record<string, any>> = RootState<any> & TCustom;\n\n/**\n * Helper to create a type-safe context value that extends AppContextValue\n * \n * @example\n * ```typescript\n * import { AppContextValue } from '@scripturecoder/rn-alpha';\n * \n * interface MyCustomFields {\n *   theme: string;\n *   setTheme: (theme: string) => void;\n * }\n * \n * type MyAppContext = ExtendedAppContext<MyCustomFields>;\n * // Includes: auth, user, connected, setAuth, setUser, clearAuth, theme, setTheme\n * ```\n */\nexport type ExtendedAppContext<TCustom extends Record<string, any>> = import('./contexts/app-context').AppContextValue & TCustom;\n\n/**\n * Helper to create strongly-typed selectors\n * \n * @example\n * ```typescript\n * const selectTheme = createSelector(\n *   (state: AppState) => state.settings.theme\n * );\n * \n * // Use in component\n * const theme = useTypedSelector(selectTheme);\n * ```\n */\nexport function createSelector<TState, TResult>(\n  selector: (state: TState) => TResult\n): (state: TState) => TResult {\n  return selector;\n}\n\n/**\n * Helper to extract state type from a reducer\n * \n * @example\n * ```typescript\n * const settingsReducer = (state, action) => { ... };\n * type SettingsState = StateFromReducer<typeof settingsReducer>;\n * ```\n */\nexport type StateFromReducer<TReducer extends (state: any, action: any) => any> = \n  TReducer extends (state: infer S, action: any) => any ? S : never;\n\n/**\n * Helper to create a strongly-typed slice\n * Convenience wrapper around Redux Toolkit's createSlice with better inference\n */\nexport { createSlice } from '@reduxjs/toolkit';\n\n/**\n * Default typed hooks that work with the core RootState\n * Can be used directly or as a starting point for your own typed hooks\n */\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useReduxSelector;\nexport const useAppDispatch = () => useReduxDispatch<AppDispatch>();\n\n","function formatMoney(num:number, decimal:number) {\n    if (num || num === 0){\n        return num.toFixed(decimal).replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1,')\n    }\n    return \"-.--\"\n}\nexport default formatMoney;\n","export default function getMime(ext:string) {\n\tconst mimeTypes:any = {\n\t\tjpg: 'image/jpeg',\n\t\tjpeg: 'image/jpeg',\n\t\tpng: 'image/png',\n\t\tgif: 'image/gif',\n\t\tbmp: 'image/bmp',\n\t\ttiff: 'image/tiff',\n\t\tpdf: 'application/pdf',\n\t\tdoc: 'application/msword',\n\t\tdocx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\t\txls: 'application/vnd.ms-excel',\n\t\txlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\t\tppt: 'application/vnd.ms-powerpoint',\n\t\tpptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n\t\ttxt: 'text/plain',\n\t\tcsv: 'text/csv',\n\t\txml: 'application/xml',\n\t\thtml: 'text/html',\n\t\tjson: 'application/json',\n\t\tmp4: 'video/mp4',\n\t\tavi: 'video/x-msvideo',\n\t\tmov: 'video/quicktime',\n\t\tmkv: 'video/x-matroska',\n\t\tmp3: 'audio/mpeg',\n\t\twav: 'audio/wav',\n\t\togg: 'audio/ogg',\n\t\tflac: 'audio/flac',\n\t\taac: 'audio/aac',\n\t\tm4a: 'audio/mp4',\n\t\tzip: 'application/zip',\n\t\trar: 'application/vnd.rar',\n\t};\n\n\treturn mimeTypes[ext.toLowerCase()] || 'application/octet-stream';\n}\n","export default function capitalize(string:string) {\n\treturn string.replace(/(?:^|\\s)\\S/g, function(a) { return a.toUpperCase(); });\n}\n","import SimpleToast from \"react-native-simple-toast\";\n\nconst Toast=(message:string, duration?:\"SHORT\"|\"LONG\")=>{\n    setTimeout(()=>{\n        SimpleToast.show(message,SimpleToast[duration||\"LONG\"])\n    },100)\n};\n\nexport default Toast;\n","import RNFetchBlob from 'react-native-blob-util';\n\nconst readFile = async (path:string) => {\n\ttry {\n\t\treturn await RNFetchBlob.fs.readFile(path.replace(\"file://\", \"\"), 'base64');\n\t} catch (error) {\n\t\tconsole.error('Error reading file:', error);\n\t\treturn null;\n\t}\n};\n\nexport default readFile\n"],"mappings":"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","names":["useEffect","useMemo","useCallback","config","createSlice","initialState","actions","createSlice","initialState","actions","config","isAbortError","isAbortError","actions","createContext","useContext","useEffect","useState","NetInfo","jsx","createContext","useContext","useMemo","useEffect","useState","useCallback","DEFAULT_CONFIG","currentConfig","config","jsx","createContext","useState","useEffect","useCallback","_a","useMemo","useContext","config","config","useEffect","actions","useCallback","isAbortError","useMemo","config","actions","isAbortError","useState","useCallback","useRef","useEffect","useState","config","useRef","useEffect","useCallback","isAbortError","useState","useCallback","useRef","useEffect","Keyboard","useState","config","useRef","useEffect","useCallback","Keyboard","isAbortError","isAbortError","shouldRetry","formatFormData","formatUrlEncoded","storage","useEffect","useRef","useRef","useEffect","useMemo","useEffect","jsx","config","useMemo","useEffect","createSlice"]}